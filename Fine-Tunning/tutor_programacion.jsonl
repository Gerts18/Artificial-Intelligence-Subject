{"instruction": "¿Qué es una variable en programación?", "response": "Una variable es un espacio en la memoria de la computadora donde guardas datos. Tienes que darle un nombre. Ejemplo: edad = 10 guarda el número 10 en la variable llamada 'edad'."}
{"instruction": "¿Para qué sirve print()?", "response": "print() muestra texto o números en la pantalla. Ejemplo: print('Hola') muestra Hola. También puedes mostrar variables: print(edad) muestra lo que tenga guardado la variable edad."}
{"instruction": "¿Cómo pido datos al usuario?", "response": "Usas input(). El programa espera a que el usuario escriba algo y presione Enter. Ejemplo: nombre = input('Escribe tu nombre: ') guarda lo escrito en la variable nombre."}
{"instruction": "¿Qué es una lista?", "response": "Una lista es una colección ordenada de elementos. Se crea con corchetes. Ejemplo: frutas = ['manzana', 'banana', 'naranja'] guarda tres elementos. Cada elemento tiene una posición: frutas[0] es 'manzana'."}
{"instruction": "¿Cómo agrego elementos a una lista?", "response": "Usas el método append(). Ejemplo: frutas = ['manzana']; frutas.append('banana'); ahora frutas tiene ['manzana', 'banana']."}
{"instruction": "¿Qué es un bucle for?", "response": "Un bucle for repite código para cada elemento de una lista o rango. Ejemplo: for fruta in ['manzana','banana']: print(fruta) imprime manzana y luego banana."}
{"instruction": "¿Qué es una condición if?", "response": "if ejecuta código solo si una condición es verdadera. Ejemplo: if edad >= 18: print('Puedes votar') solo imprime si edad es 18 o más."}
{"instruction": "¿Cómo comparo si dos cosas son iguales?", "response": "Usas == (dos signos igual). Ejemplo: if nombre == 'Ana': print('Hola Ana') compara si nombre tiene el valor 'Ana'."}
{"instruction": "¿Qué es una función?", "response": "Una función es un bloque de código que realiza una tarea específica. Se define una vez y se puede usar muchas veces. Ejemplo: def saludar(): print('Hola') crea una función. Luego saludar() la ejecuta."}
{"instruction": "¿Cómo creo una función con parámetros?", "response": "Los parámetros son variables que la función recibe. Ejemplo: def sumar(a, b): return a + b. Luego resultado = sumar(3, 4) guarda 7 en resultado."}
{"instruction": "¿Qué es un número entero (int)?", "response": "int es un tipo de dato para números sin decimales. Ejemplo: 5, -3, 0 son enteros. Python los reconoce sin comillas: numero = 5."}
{"instruction": "¿Qué es un número decimal (float)?", "response": "float es un tipo de dato para números con punto decimal. Ejemplo: 3.14, 2.5, -0.7. Se escriben con punto: precio = 9.99."}
{"instruction": "¿Cómo convierto texto a número?", "response": "Usas int() para enteros o float() para decimales. Ejemplo: texto = '10'; numero = int(texto) convierte '10' a 10. Si el texto no es número, da error."}
{"instruction": "¿Cómo convierto número a texto?", "response": "Usas str(). Ejemplo: edad = 10; texto = 'Tengo ' + str(edad) + ' años' convierte 10 a '10' para poder unirlo con texto."}
{"instruction": "¿Qué es un comentario en código?", "response": "Un comentario es texto que Python no ejecuta. Sirve para explicar el código. Se escribe con #. Ejemplo: # Esto calcula el promedio; promedio = (a+b)/2."}
{"instruction": "¿Cómo ordeno una lista?", "response": "Usas el método sort(). Ejemplo: numeros = [3,1,2]; numeros.sort() cambia la lista a [1,2,3]. La lista original se modifica."}
{"instruction": "¿Cómo obtengo el tamaño de una lista?", "response": "Usas len(). Ejemplo: frutas = ['manzana','banana']; tamaño = len(frutas) guarda 2 en tamaño."}
{"instruction": "¿Qué hace range(5)?", "response": "range(5) genera una secuencia de números del 0 al 4. Se usa en bucles: for i in range(5): print(i) imprime 0,1,2,3,4."}
{"instruction": "¿Qué es un error de sintaxis?", "response": "Es un error en la escritura del código. Python no puede ejecutarlo. Ejemplo: print('Hola' sin cerrar el paréntesis causa SyntaxError."}
{"instruction": "¿Qué es un error en tiempo de ejecución?", "response": "Es un error que ocurre cuando Python intenta ejecutar código incorrecto. Ejemplo: int('abc') causa ValueError porque 'abc' no es número."}
{"instruction": "¿Cómo evito que el programa se detenga por errores?", "response": "Usas try y except. Ejemplo: try: numero = int('abc'); except: print('No es número') evita que el programa se detenga si hay error."}
{"instruction": "¿Qué es un diccionario?", "response": "Un diccionario guarda pares de clave y valor. Ejemplo: datos = {'nombre':'Ana','edad':20}. Para acceder: datos['nombre'] da 'Ana'."}
{"instruction": "¿Cómo recorro un diccionario?", "response": "Puedes recorrer claves, valores o ambos. Ejemplo: for clave in datos: print(clave) imprime las claves. Para valores: datos[clave]."}
{"instruction": "¿Qué es una tupla?", "response": "Una tupla es como una lista pero no se puede modificar después de crearla. Ejemplo: coordenadas = (10,20). coordenadas[0] da 10, pero no puedes cambiar ese valor."}
{"instruction": "¿Qué es un conjunto (set)?", "response": "Un conjunto es una colección sin orden que no permite elementos duplicados. Ejemplo: numeros = {1,2,2,3} se convierte en {1,2,3}."}
{"instruction": "¿Cómo elimino un elemento de una lista?", "response": "Usas remove() para eliminar por valor, o pop() para eliminar por posición. Ejemplo: lista = [1,2,3]; lista.remove(2) elimina el 2; lista.pop(0) elimina el primer elemento."}
{"instruction": "¿Qué hace el operador %?", "response": "% calcula el resto de una división. Ejemplo: 10 % 3 da 1, porque 10 dividido entre 3 es 3 y sobra 1."}
{"instruction": "¿Cómo sé si un número es par?", "response": "Un número es par si al dividirlo entre 2 el resto es 0. Ejemplo: if numero % 2 == 0: print('Es par') else: print('Es impar')."}
{"instruction": "¿Qué es un bucle while?", "response": "while repite código mientras una condición sea verdadera. Ejemplo: contador = 0; while contador < 3: print(contador); contador += 1 imprime 0,1,2."}
{"instruction": "¿Qué es un bucle infinito?", "response": "Es un bucle que nunca termina porque la condición siempre es verdadera. Ejemplo: while True: print('hola') imprime 'hola' indefinidamente."}
{"instruction": "¿Cómo detengo un bucle antes de tiempo?", "response": "Usas break. Ejemplo: for i in range(10): if i == 5: break; print(i) imprime 0,1,2,3,4 y luego se detiene."}
{"instruction": "¿Qué es elif?", "response": "elif verifica otra condición si la condición del if es falsa. Ejemplo: if x > 10: print('Mayor'); elif x == 10: print('Igual'); else: print('Menor')."}
{"instruction": "¿Qué es else?", "response": "else ejecuta código cuando todas las condiciones anteriores (if, elif) son falsas. Ejemplo: if edad >= 18: print('Mayor'); else: print('Menor')."}
{"instruction": "¿Cómo sumo todos los elementos de una lista?", "response": "Usas sum(). Ejemplo: numeros = [1,2,3]; total = sum(numeros) guarda 6 en total."}
{"instruction": "¿Cómo encuentro el valor más grande en una lista?", "response": "Usas max(). Ejemplo: numeros = [5,2,8]; mayor = max(numeros) guarda 8 en mayor."}
{"instruction": "¿Cómo importo un módulo?", "response": "Usas import. Ejemplo: import random; numero = random.randint(1,6) importa el módulo random y genera un número aleatorio del 1 al 6."}
{"instruction": "¿Qué hace random.randint(1,10)?", "response": "Genera un número entero aleatorio entre 1 y 10 (incluyendo ambos). Ejemplo: import random; dado = random.randint(1,6) simula un dado de 6 caras."}
{"instruction": "¿Cómo leo un archivo de texto?", "response": "Usas open() con modo 'r' y read(). Ejemplo: archivo = open('datos.txt','r'); contenido = archivo.read(); archivo.close(). contenido tiene el texto del archivo."}
{"instruction": "¿Cómo escribo en un archivo?", "response": "Usas open() con modo 'w' y write(). Ejemplo: archivo = open('salida.txt','w'); archivo.write('Hola mundo'); archivo.close(). Crea o sobrescribe el archivo con 'Hola mundo'."}
{"instruction": "¿Qué es una clase?", "response": "Una clase es una plantilla para crear objetos. Define atributos (datos) y métodos (funciones). Ejemplo: class Persona: def __init__(self,nombre): self.nombre = nombre."}
{"instruction": "¿Cómo creo un objeto?", "response": "Llamas a la clase como si fuera una función. Ejemplo: persona1 = Persona('Ana') crea un objeto Persona con nombre 'Ana'."}
{"instruction": "¿Qué es un método?", "response": "Un método es una función dentro de una clase. Ejemplo: class Persona: def saludar(self): print('Hola') es un método. Se llama con persona1.saludar()."}
{"instruction": "¿Qué es la herencia?", "response": "La herencia permite que una clase obtenga métodos y atributos de otra clase. Ejemplo: class Estudiante(Persona): crea clase Estudiante que hereda de Persona."}
{"instruction": "¿Qué es un módulo en Python?", "response": "Un módulo es un archivo .py que contiene código Python. Puedes importar sus funciones. Ejemplo: si tienes calculos.py, puedes hacer import calculos."}
{"instruction": "¿Qué es un paquete?", "response": "Un paquete es una carpeta que contiene varios módulos y un archivo __init__.py. Sirve para organizar código en grandes proyectos."}
{"instruction": "¿Cómo empiezo a escribir un programa?", "response": "Creas un archivo con extensión .py, escribes código Python, y lo ejecutas. Ejemplo: programa.py con print('Hola'); se ejecuta con python programa.py."}
{"instruction": "¿Qué es un algoritmo?", "response": "Un algoritmo es una serie de pasos para resolver un problema. Ejemplo: algoritmo para sumar dos números: 1) pedir primer número, 2) pedir segundo número, 3) sumarlos, 4) mostrar resultado."}
{"instruction": "¿Qué es programación estructurada?", "response": "Es escribir programas usando tres estructuras básicas: secuencia (pasos en orden), selección (if/else), y repetición (bucles). Esto hace el código más claro."}
{"instruction": "¿Qué es una constante?", "response": "Una constante es una variable cuyo valor no debe cambiar durante el programa. En Python se usan mayúsculas por convención. Ejemplo: PI = 3.1416."}
{"instruction": "¿Cómo hago mi código más fácil de leer?", "response": "Usando nombres claros para variables, escribiendo comentarios cuando sea necesario, y manteniendo una estructura consistente. Ejemplo: usar edad en lugar de x."}
{"instruction": "¿Qué son los operadores aritméticos?", "response": "Son símbolos para operaciones matemáticas: + suma, - resta, * multiplicación, / división, % resto, ** exponente. Ejemplo: 5 + 3 da 8, 10 / 3 da 3.333."}
{"instruction": "¿Qué son los operadores de comparación?", "response": "Son símbolos para comparar valores: == igual, != diferente, > mayor, < menor, >= mayor o igual, <= menor o igual. Ejemplo: if edad >= 18: verifica si edad es 18 o más."}
{"instruction": "¿Qué son los operadores lógicos?", "response": "Son and (y), or (o), not (no). and requiere que ambas condiciones sean verdaderas, or requiere al menos una, not invierte el valor. Ejemplo: if edad >= 18 and tiene_licencia: verifica ambas condiciones."}
{"instruction": "¿Cómo creo una lista vacía?", "response": "Usas dos corchetes sin nada dentro. Ejemplo: lista = [] crea una lista vacía. Luego puedes agregar elementos con lista.append(valor)."}
{"instruction": "¿Cómo creo una copia de una lista?", "response": "Usas .copy() o slicing [:]. Ejemplo: lista1 = [1,2,3]; lista2 = lista1.copy() crea una copia independiente. Cambios en lista2 no afectan lista1."}
{"instruction": "¿Cómo uno dos listas?", "response": "Usas el operador + o el método extend(). Ejemplo: lista1 = [1,2]; lista2 = [3,4]; lista3 = lista1 + lista2 da [1,2,3,4]."}
{"instruction": "¿Cómo creo una función que multiplique dos números?", "response": "Defines la función con def y dos parámetros, luego retornas la multiplicación. Ejemplo: def multiplicar(a, b): return a * b. Luego usas: resultado = multiplicar(3, 4) que guarda 12."}
{"instruction": "¿Cómo verifico si un elemento está en una lista?", "response": "Usas el operador in. Ejemplo: frutas = ['manzana','banana']; if 'manzana' in frutas: print('Sí está'). También puedes usar in para verificar si no está con not in."}
{"instruction": "¿Cómo cuento cuántas veces aparece algo en una lista?", "response": "Usas el método count(). Ejemplo: numeros = [1,2,2,3,2]; cantidad = numeros.count(2) guarda 3, porque el 2 aparece tres veces."}
{"instruction": "¿Cómo reemplazo parte de un texto (string)?", "response": "Usas el método replace(). Ejemplo: texto = 'Hola mundo'; nuevo = texto.replace('mundo', 'Python') guarda 'Hola Python' en nuevo."}
{"instruction": "¿Cómo divido un texto en palabras?", "response": "Usas el método split(). Por defecto divide por espacios. Ejemplo: texto = 'Hola mundo Python'; palabras = texto.split() guarda ['Hola','mundo','Python']."}
{"instruction": "¿Cómo uno varias palabras en un texto?", "response": "Usas el método join(). Ejemplo: palabras = ['Hola','mundo']; texto = ' '.join(palabras) guarda 'Hola mundo' (con espacio entre)."}
{"instruction": "¿Cómo cambio un texto a mayúsculas?", "response": "Usas el método upper(). Ejemplo: texto = 'hola'; mayus = texto.upper() guarda 'HOLA'."}
{"instruction": "¿Cómo cambio un texto a minúsculas?", "response": "Usas el método lower(). Ejemplo: texto = 'HOLA'; minus = texto.lower() guarda 'hola'."}
{"instruction": "¿Qué hace el método strip()?", "response": "Elimina espacios en blanco al inicio y final de un texto. Ejemplo: texto = '  hola  '; limpio = texto.strip() guarda 'hola'."}
{"instruction": "¿Cómo formateo texto con variables?", "response": "Usas f-strings. Ejemplo: nombre = 'Ana'; edad = 20; texto = f'{nombre} tiene {edad} años' guarda 'Ana tiene 20 años'."}
{"instruction": "¿Cómo redondeo un número decimal?", "response": "Usas la función round(). Ejemplo: numero = 3.14159; redondeado = round(numero, 2) guarda 3.14 (2 decimales)."}
{"instruction": "¿Cómo obtengo la parte entera de un decimal?", "response": "Usas int() sobre un float, que trunca (quita los decimales). Ejemplo: numero = 3.9; entero = int(numero) guarda 3."}
{"instruction": "¿Cómo elevo un número a una potencia?", "response": "Usas el operador ** o la función pow(). Ejemplo: 2**3 da 8, pow(2,3) también da 8."}
{"instruction": "¿Cómo obtengo la raíz cuadrada?", "response": "Usas math.sqrt() después de importar math. Ejemplo: import math; raiz = math.sqrt(16) guarda 4.0."}
{"instruction": "¿Qué hace // en división?", "response": "Es división entera (piso). Da el cociente sin decimales, truncando hacia abajo. Ejemplo: 7 // 2 da 3."}
{"instruction": "¿Cómo genero números aleatorios decimales?", "response": "Usas random.random() para número entre 0 y 1, o random.uniform(a,b) para rango. Ejemplo: import random; x = random.uniform(1.0, 5.0)."}
{"instruction": "¿Cómo mezclo una lista al azar?", "response": "Usas random.shuffle(). Ejemplo: import random; lista = [1,2,3]; random.shuffle(lista) mezcla el orden de lista."}
{"instruction": "¿Cómo elijo un elemento al azar de una lista?", "response": "Usas random.choice(). Ejemplo: import random; lista = ['a','b','c']; elemento = random.choice(lista) elige uno al azar."}
{"instruction": "¿Cómo creo una lista de números del 1 al 10?", "response": "Usas list() con range(). Ejemplo: numeros = list(range(1, 11)) crea [1,2,3,4,5,6,7,8,9,10]."}
{"instruction": "¿Cómo creo una lista con los mismos números multiplicados por 2?", "response": "Puedes usar un bucle for o comprensión de lista. Ejemplo: original = [1,2,3]; dobles = [x*2 for x in original] crea [2,4,6]."}
{"instruction": "¿Cómo filtro una lista para quedarme solo con números pares?", "response": "Usas comprensión de lista con condición. Ejemplo: numeros = [1,2,3,4,5,6]; pares = [x for x in numeros if x%2==0] crea [2,4,6]."}
{"instruction": "¿Cómo combino dos listas en pares?", "response": "Usas zip(). Ejemplo: nombres = ['Ana','Juan']; edades = [20,25]; parejas = list(zip(nombres, edades)) crea [('Ana',20),('Juan',25)]."}
{"instruction": "¿Cómo obtengo los elementos únicos de una lista?", "response": "Conviertes la lista a conjunto (set) y luego de vuelta a lista. Ejemplo: lista = [1,2,2,3]; unicos = list(set(lista)) crea [1,2,3] (orden puede cambiar)."}
{"instruction": "¿Cómo invierto el orden de una lista?", "response": "Usas el método reverse() o slicing [::-1]. Ejemplo: lista = [1,2,3]; lista.reverse() modifica a [3,2,1]. O invertida = lista[::-1] crea nueva lista."}
{"instruction": "¿Cómo copio solo una parte de una lista?", "response": "Usas slicing. Ejemplo: lista = [1,2,3,4,5]; parte = lista[1:4] guarda [2,3,4] (índice 1 al 3)."}
{"instruction": "¿Cómo ordeno una lista de mayor a menor?", "response": "Usas sort() con reverse=True. Ejemplo: numeros = [3,1,2]; numeros.sort(reverse=True) modifica a [3,2,1]."}
{"instruction": "¿Cómo ordeno una lista sin modificar la original?", "response": "Usas sorted(). Ejemplo: original = [3,1,2]; ordenada = sorted(original) crea [1,2,3]; original sigue siendo [3,1,2]."}
{"instruction": "¿Cómo creo una lista de listas (matriz)?", "response": "Pones listas dentro de una lista. Ejemplo: matriz = [[1,2,3],[4,5,6],[7,8,9]]. Para acceder: matriz[0][1] da 2 (fila 0, columna 1)."}
{"instruction": "¿Cómo sumo todos los elementos de una matriz?", "response": "Puedes usar bucles anidados o sum() con comprensión. Ejemplo: matriz = [[1,2],[3,4]]; total = sum(sum(fila) for fila in matriz) da 10."}
{"instruction": "¿Cómo cambio un valor en un diccionario?", "response": "Asignas nuevo valor a una clave existente. Ejemplo: datos = {'a':1, 'b':2}; datos['a'] = 10 cambia el valor de 'a' a 10."}
{"instruction": "¿Cómo agrego un nuevo par clave-valor a un diccionario?", "response": "Asignas valor a una nueva clave. Ejemplo: datos = {}; datos['nombre'] = 'Ana' agrega clave 'nombre' con valor 'Ana'."}
{"instruction": "¿Cómo elimino un elemento de un diccionario?", "response": "Usas del o pop(). Ejemplo: datos = {'a':1,'b':2}; del datos['a'] elimina la clave 'a'. O valor = datos.pop('a') elimina y devuelve el valor."}
{"instruction": "¿Cómo obtengo todas las claves de un diccionario?", "response": "Usas el método keys(). Ejemplo: datos = {'a':1,'b':2}; claves = list(datos.keys()) da ['a','b']."}
{"instruction": "¿Cómo obtengo todos los valores de un diccionario?", "response": "Usas el método values(). Ejemplo: datos = {'a':1,'b':2}; valores = list(datos.values()) da [1,2]."}
{"instruction": "¿Cómo recorro un diccionario obteniendo claves y valores?", "response": "Usas el método items(). Ejemplo: for clave, valor in datos.items(): print(clave, valor)."}
{"instruction": "¿Cómo verifico si una clave existe en un diccionario?", "response": "Usas el operador in. Ejemplo: if 'nombre' in datos: print('Existe')."}
{"instruction": "¿Cómo creo un diccionario vacío?", "response": "Usas llaves vacías o dict(). Ejemplo: datos = {} o datos = dict()."}
{"instruction": "¿Cómo creo un diccionario a partir de dos listas?", "response": "Usas zip() con dict(). Ejemplo: claves = ['a','b']; valores = [1,2]; datos = dict(zip(claves, valores)) crea {'a':1,'b':2}."}
{"instruction": "¿Cómo actualizo un diccionario con otro diccionario?", "response": "Usas el método update(). Ejemplo: datos1 = {'a':1}; datos2 = {'b':2}; datos1.update(datos2) deja datos1 como {'a':1,'b':2}."}
{"instruction": "¿Cómo obtengo un valor de diccionario sin error si la clave no existe?", "response": "Usas get() con valor por defecto. Ejemplo: valor = datos.get('clave', 0) da el valor si existe, o 0 si no."}
{"instruction": "¿Qué es y cómo uso enumerate()?", "response": "enumerate() da el índice y valor al recorrer una lista. Ejemplo: lista = ['a','b']; for i, valor in enumerate(lista): print(i, valor) imprime 0 a, 1 b."}
{"instruction": "¿Qué es y cómo uso range() con tres parámetros?", "response": "range(inicio, fin, paso). Ejemplo: list(range(0, 10, 2)) crea [0,2,4,6,8]. Va desde inicio hasta fin-1, incrementando por paso."}
{"instruction": "¿Cómo sé el tipo de dato de una variable?", "response": "Usas type(). Ejemplo: x = 5; tipo = type(x) da <class 'int'>."}
{"instruction": "¿Cómo verifico si una variable es de cierto tipo?", "response": "Usas isinstance(). Ejemplo: x = 5; if isinstance(x, int): print('Es entero')."}
{"instruction": "¿Cómo manejo varios tipos de errores específicos?", "response": "Puedes tener varios except. Ejemplo: try: código; except ValueError: manejo; except TypeError: manejo."}
{"instruction": "¿Cómo abro un archivo para leer línea por línea?", "response": "Usas un bucle for sobre el archivo. Ejemplo: with open('archivo.txt','r') as f: for linea in f: print(linea.strip())."}
{"instruction": "¿Cómo escribo varias líneas en un archivo?", "response": "Puedes usar writelines() o múltiples write(). Ejemplo: lineas = ['línea1','línea2']; with open('salida.txt','w') as f: f.writelines(linea+'\\n' for linea in lineas)."}
{"instruction": "¿Cómo verifico si un archivo existe?", "response": "Usas os.path.exists() del módulo os. Ejemplo: import os; if os.path.exists('archivo.txt'): print('Existe')."}
{"instruction": "¿Cómo creo una función con valor por defecto en parámetros?", "response": "Asignas valor en la definición. Ejemplo: def saludar(nombre='mundo'): print(f'Hola {nombre}'). saludar() usa 'mundo', saludar('Ana') usa 'Ana'."}
{"instruction": "¿Cómo creo una función que recibe cualquier número de argumentos?", "response": "Usas *args. Ejemplo: def sumar(*args): return sum(args). sumar(1,2,3) da 6."}
{"instruction": "¿Cómo creo una función que recibe cualquier número de argumentos con nombre?", "response": "Usas **kwargs. Ejemplo: def mostrar(**kwargs): for clave, valor in kwargs.items(): print(clave, valor). mostrar(nombre='Ana',edad=20)."}
{"instruction": "¿Qué es una función lambda?", "response": "Es una función pequeña y anónima. Ejemplo: doble = lambda x: x*2; doble(5) da 10."}
{"instruction": "¿Cómo aplico una función a todos los elementos de una lista?", "response": "Puedes usar map() o comprensión. Ejemplo: lista = [1,2,3]; dobles = list(map(lambda x: x*2, lista)) da [2,4,6]."}
{"instruction": "¿Cómo filtro una lista con una condición?", "response": "Puedes usar filter() o comprensión. Ejemplo: lista = [1,2,3,4]; pares = list(filter(lambda x: x%2==0, lista)) da [2,4]."}
{"instruction": "¿Cómo calculo el promedio de una lista?", "response": "Sumas los elementos y divides por el tamaño. Ejemplo: lista = [1,2,3]; promedio = sum(lista)/len(lista) da 2.0."}
{"instruction": "¿Cómo sé si un texto empieza con cierta palabra?", "response": "Usas el método startswith(). Ejemplo: texto = 'Python es genial'; if texto.startswith('Python'): print('Empieza con Python')."}
{"instruction": "¿Cómo sé si un texto termina con cierta palabra?", "response": "Usas el método endswith(). Ejemplo: texto = 'archivo.txt'; if texto.endswith('.txt'): print('Es un archivo de texto')."}
{"instruction": "¿Cómo cuento cuántas palabras hay en un texto?", "response": "Usas split() y len(). Ejemplo: texto = 'Hola mundo Python'; palabras = texto.split(); cantidad = len(palabras) da 3."}
{"instruction": "¿Cómo cambio la primera letra de cada palabra a mayúscula?", "response": "Usas el método title(). Ejemplo: texto = 'hola mundo'; titulo = texto.title() guarda 'Hola Mundo'."}
{"instruction": "¿Cómo encuentro la posición de una palabra en un texto?", "response": "Usas el método find(). Ejemplo: texto = 'Hola mundo'; pos = texto.find('mundo') guarda 5 (posición donde empieza). Si no encuentra, devuelve -1."}
{"instruction": "¿Cómo separo un texto por líneas?", "response": "Usas splitlines(). Ejemplo: texto = 'línea1\\nlínea2'; lineas = texto.splitlines() guarda ['línea1','línea2']."}
{"instruction": "¿Cómo verifico si un texto contiene solo letras?", "response": "Usas el método isalpha(). Ejemplo: texto = 'Hola'; if texto.isalpha(): print('Solo letras'). Los espacios o números dan False."}
{"instruction": "¿Cómo verifico si un texto contiene solo números?", "response": "Usas isdigit() para dígitos o isnumeric() para números más generales. Ejemplo: '123'.isdigit() da True; '12.5'.isdigit() da False."}
{"instruction": "¿Cómo relleno un texto con ceros a la izquierda?", "response": "Usas zfill(). Ejemplo: num = '5'; relleno = num.zfill(3) guarda '005' (hasta 3 caracteres)."}
{"instruction": "¿Cómo centro un texto dentro de un ancho específico?", "response": "Usas center(). Ejemplo: texto = 'Hola'; centrado = texto.center(10) guarda '   Hola   ' (10 caracteres total)."}
{"instruction": "¿Cómo elimino solo los espacios de la derecha de un texto?", "response": "Usas rstrip(). Ejemplo: texto = 'hola   '; limpio = texto.rstrip() guarda 'hola'."}
{"instruction": "¿Cómo elimino solo los espacios de la izquierda de un texto?", "response": "Usas lstrip(). Ejemplo: texto = '   hola'; limpio = texto.lstrip() guarda 'hola'."}
{"instruction": "¿Cómo divido un texto en partes por un separador específico?", "response": "Usas split() con argumento. Ejemplo: texto = 'a,b,c'; partes = texto.split(',') guarda ['a','b','c']."}
{"instruction": "¿Cómo uno textos con un separador específico?", "response": "Usas join() con el separador. Ejemplo: palabras = ['a','b','c']; texto = '-'.join(palabras) guarda 'a-b-c'."}
{"instruction": "¿Cómo reemplazo múltiples espacios por uno solo?", "response": "Puedes usar split() y join(). Ejemplo: texto = 'Hola    mundo'; palabras = texto.split(); limpio = ' '.join(palabras) guarda 'Hola mundo'."}
{"instruction": "¿Cómo obtengo el mínimo y máximo de una lista en una sola línea?", "response": "Usas min() y max() juntas. Ejemplo: lista = [5,2,8]; minimo, maximo = min(lista), max(lista). minimo es 2, maximo es 8."}
{"instruction": "¿Cómo sumo dos listas elemento por elemento?", "response": "Usas zip() y comprensión de lista. Ejemplo: a = [1,2,3]; b = [4,5,6]; suma = [x+y for x,y in zip(a,b)] guarda [5,7,9]."}
{"instruction": "¿Cómo multiplico todos los elementos de una lista entre sí?", "response": "Usas un bucle o reduce() de functools. Ejemplo: from functools import reduce; lista = [1,2,3,4]; producto = reduce(lambda x,y: x*y, lista) guarda 24."}
{"instruction": "¿Cómo creo una lista de números pares del 0 al 20?", "response": "Usas range() con paso 2. Ejemplo: pares = list(range(0,21,2)) guarda [0,2,4,6,8,10,12,14,16,18,20]."}
{"instruction": "¿Cómo creo una lista con los cuadrados de los números del 1 al 10?", "response": "Usas comprensión de lista. Ejemplo: cuadrados = [x**2 for x in range(1,11)] guarda [1,4,9,16,25,36,49,64,81,100]."}
{"instruction": "¿Cómo aplanar una lista de listas en una sola lista?", "response": "Usas comprensión anidada o itertools.chain(). Ejemplo: lista_de_listas = [[1,2],[3,4]]; aplanada = [item for sublist in lista_de_listas for item in sublist] guarda [1,2,3,4]."}
{"instruction": "¿Cómo encuentro el índice de un elemento en una lista?", "response": "Usas el método index(). Ejemplo: lista = ['a','b','c']; pos = lista.index('b') guarda 1. Si no existe, da ValueError."}
{"instruction": "¿Cómo inserto un elemento en una posición específica de una lista?", "response": "Usas insert(). Ejemplo: lista = [1,2,3]; lista.insert(1, 99) cambia la lista a [1,99,2,3] (inserta en posición 1)."}
{"instruction": "¿Cómo elimino todos los elementos de una lista que cumplen una condición?", "response": "Usas comprensión de lista con filtro. Ejemplo: lista = [1,2,3,4,5]; nueva = [x for x in lista if x%2==0] guarda [2,4] (solo pares)."}
{"instruction": "¿Cómo creo una lista con elementos únicos manteniendo el orden?", "response": "Puedes usar un bucle. Ejemplo: lista = [1,2,2,3,1]; unicos = []; for x in lista: if x not in unicos: unicos.append(x) guarda [1,2,3]."}
{"instruction": "¿Cómo divido una lista en dos partes (pares e impares)?", "response": "Usas dos comprensiones de lista. Ejemplo: lista = [1,2,3,4,5]; pares = [x for x in lista if x%2==0]; impares = [x for x in lista if x%2!=0]."}
{"instruction": "¿Cómo roto los elementos de una lista (mover el último al principio)?", "response": "Usas slicing. Ejemplo: lista = [1,2,3,4]; rotada = [lista[-1]] + lista[:-1] guarda [4,1,2,3]."}
{"instruction": "¿Cómo repito cada elemento de una lista N veces?", "response": "Usas comprensión de lista anidada. Ejemplo: lista = [1,2]; repetida = [x for x in lista for _ in range(3)] guarda [1,1,1,2,2,2]."}
{"instruction": "¿Cómo intercalo dos listas?", "response": "Usas zip() y aplanamiento. Ejemplo: a=[1,2]; b=['a','b']; intercalada = [item for par in zip(a,b) for item in par] guarda [1,'a',2,'b']."}
{"instruction": "¿Cómo calculo la diferencia entre dos listas (elementos en A que no están en B)?", "response": "Puedes usar comprensión de lista. Ejemplo: a=[1,2,3,4]; b=[3,4,5]; diff = [x for x in a if x not in b] guarda [1,2]."}
{"instruction": "¿Cómo cuento cuántos elementos de una lista son mayores que 10?", "response": "Usas sum() con comprensión. Ejemplo: lista = [5,12,8,15]; cuenta = sum(1 for x in lista if x>10) guarda 2."}
{"instruction": "¿Cómo encuentro el segundo mayor valor en una lista?", "response": "Ordenas y tomas el penúltimo. Ejemplo: lista = [5,1,8,3]; ordenada = sorted(lista); segundo_mayor = ordenada[-2] guarda 5."}
{"instruction": "¿Cómo calculo el promedio de números positivos en una lista?", "response": "Filtros y luego calculas. Ejemplo: lista = [5,-2,10,-3]; positivos = [x for x in lista if x>0]; promedio = sum(positivos)/len(positivos)."}
{"instruction": "¿Cómo sé si todos los elementos de una lista cumplen una condición?", "response": "Usas all(). Ejemplo: lista = [2,4,6]; if all(x%2==0 for x in lista): print('Todos pares')."}
{"instruction": "¿Cómo sé si al menos un elemento de una lista cumple una condición?", "response": "Usas any(). Ejemplo: lista = [1,3,6]; if any(x%2==0 for x in lista): print('Hay al menos un par')."}
{"instruction": "¿Cómo creo una lista de números aleatorios?", "response": "Usas random.randint() en comprensión. Ejemplo: import random; aleatorios = [random.randint(1,100) for _ in range(10)] crea 10 números entre 1 y 100."}
{"instruction": "¿Cómo muestro una lista de forma más legible?", "response": "Puedes usar un bucle con formato. Ejemplo: lista = ['a','b','c']; for i, item in enumerate(lista): print(f'{i}: {item}') muestra con índices."}
{"instruction": "¿Cómo creo una copia profunda de una lista con listas dentro?", "response": "Usas copy.deepcopy(). Ejemplo: import copy; original = [[1,2],[3,4]]; copia = copy.deepcopy(original). Cambios en copia no afectan original."}
{"instruction": "¿Cómo transformo una lista en una cadena con separadores?", "response": "Usas join() convirtiendo elementos a string. Ejemplo: lista = [1,2,3]; texto = ','.join(str(x) for x in lista) guarda '1,2,3'."}
{"instruction": "¿Cómo obtengo los últimos N elementos de una lista?", "response": "Usas slicing negativo. Ejemplo: lista = [1,2,3,4,5]; ultimos = lista[-3:] guarda [3,4,5] (últimos 3)."}
{"instruction": "¿Cómo obtengo cada segundo elemento de una lista?", "response": "Usas slicing con paso. Ejemplo: lista = [1,2,3,4,5]; cada_segundo = lista[::2] guarda [1,3,5]."}
{"instruction": "¿Cómo calculo la suma acumulada de una lista?", "response": "Usas un bucle. Ejemplo: lista = [1,2,3,4]; acumulada = []; total=0; for x in lista: total+=x; acumulada.append(total) guarda [1,3,6,10]."}
{"instruction": "¿Cómo encuentro el elemento más frecuente en una lista?", "response": "Puedes usar max() con count. Ejemplo: lista = [1,2,2,3,2]; mas_frecuente = max(set(lista), key=lista.count) guarda 2."}
{"instruction": "¿Cómo divido una lista en partes de tamaño fijo?", "response": "Usas un bucle con slicing. Ejemplo: lista = [1,2,3,4,5,6]; tamaño=2; partes = [lista[i:i+tamaño] for i in range(0,len(lista),tamaño)] guarda [[1,2],[3,4],[5,6]]."}
{"instruction": "¿Cómo mezclo dos listas intercalando sus elementos?", "response": "Usas zip() y aplanar. Ejemplo: a=[1,2,3]; b=['a','b','c']; mezcla = [val for par in zip(a,b) for val in par] guarda [1,'a',2,'b',3,'c']."}
{"instruction": "¿Cómo elimino duplicados de una lista manteniendo el orden?", "response": "Usas un bucle o dict.fromkeys(). Ejemplo: lista = [1,2,2,3,1]; sin_duplicados = list(dict.fromkeys(lista)) guarda [1,2,3]."}
{"instruction": "¿Cómo reemplazo un valor en todas las posiciones de una lista?", "response": "Usas comprensión de lista. Ejemplo: lista = [1,2,3,2]; reemplazada = [99 if x==2 else x for x in lista] guarda [1,99,3,99]."}
{"instruction": "¿Cómo calculo el producto punto de dos listas?", "response": "Usas sum() con zip(). Ejemplo: a=[1,2,3]; b=[4,5,6]; producto = sum(x*y for x,y in zip(a,b)) guarda 32."}
{"instruction": "¿Cómo normalizo una lista (escalar valores entre 0 y 1)?", "response": "Restas el mínimo y divides por el rango. Ejemplo: lista = [10,20,30]; minimo=min(lista); rango=max(lista)-min(listo); normalizada = [(x-minimo)/rango for x in lista]."}
{"instruction": "¿Cómo creo una lista con números consecutivos?", "response": "Usas range() directamente. Ejemplo: consecutivos = list(range(5)) guarda [0,1,2,3,4]."}
{"instruction": "¿Cómo convierto una lista de números en una lista de strings?", "response": "Usas map() o comprensión. Ejemplo: numeros = [1,2,3]; strings = list(map(str, numeros)) guarda ['1','2','3']."}
{"instruction": "¿Cómo encuentro la mediana de una lista?", "response": "Ordenas y tomas el del medio. Ejemplo: lista = [3,1,2]; ordenada = sorted(lista); mediana = ordenada[len(ordenada)//2] si es impar."}
{"instruction": "¿Cómo aplico una función a elementos de lista y creo nueva lista?", "response": "Usas map() o comprensión. Ejemplo: def doble(x): return x*2; lista=[1,2,3]; resultado = list(map(doble, lista)) guarda [2,4,6]."}
{"instruction": "¿Qué es Python y para qué sirve?", "response": "Python es un lenguaje de programación. Sirve para crear programas de computadora, desde simples scripts hasta aplicaciones complejas. Se usa mucho para análisis de datos, inteligencia artificial, desarrollo web y automatización."}
{"instruction": "¿Necesito algo especial en mi computadora para programar en Python?", "response": "Solo necesitas instalar Python desde python.org y un editor de texto. Puedes usar editores simples como Notepad++ o IDLE que viene con Python. También puedes usar entornos como VS Code o PyCharm, pero no son obligatorios."}
{"instruction": "¿Cómo escribo mi primer programa?", "response": "Abre un editor de texto, escribe: print('Hola mundo'). Guarda el archivo como programa.py. Abre la terminal o consola, navega a la carpeta donde está el archivo y ejecuta: python programa.py. Verás 'Hola mundo' en pantalla."}
{"instruction": "¿Por qué a veces los programas no funcionan?", "response": "Los programas no funcionan por errores de escritura (sintaxis), errores de lógica (instrucciones incorrectas) o problemas con los datos. Python te mostrará mensajes de error que indican qué línea tiene el problema."}
{"instruction": "¿Qué significa 'sintaxis' en programación?", "response": "La sintaxis son las reglas de escritura de un lenguaje. En Python, cada instrucción tiene una forma específica de escribirse. Si escribes mal una palabra o olvidas un símbolo, tendrás un error de sintaxis."}
{"instruction": "¿Qué hago cuando veo un mensaje de error?", "response": "Lee el mensaje de error. Te dice qué tipo de error es y en qué línea. Los errores comunes son: SyntaxError (error de escritura), NameError (variable no definida), TypeError (operación con tipos incorrectos). Corrige lo que indica el mensaje."}
{"instruction": "¿Cuál es la diferencia entre mayúsculas y minúsculas en Python?", "response": "Python distingue entre mayúsculas y minúsculas. 'Variable', 'variable' y 'VARIABLE' son tres nombres diferentes. Debes usar consistentemente el mismo uso de mayúsculas."}
{"instruction": "¿Puedo usar espacios en los nombres de variables?", "response": "No puedes usar espacios. Usa guiones bajos para separar palabras. Ejemplo: mi_variable en lugar de 'mi variable'."}
{"instruction": "¿Qué tipos de datos básicos existen?", "response": "Los tipos básicos son: int (números enteros como 5), float (números decimales como 3.14), str (texto como 'hola'), bool (valores True o False). Python los reconoce automáticamente."}
{"instruction": "¿Cómo sé qué tipo de dato tengo?", "response": "Usa type(). Ejemplo: type(5) muestra <class 'int'>, type('hola') muestra <class 'str'>."}
{"instruction": "¿Qué operaciones puedo hacer con números?", "response": "Suma (+), resta (-), multiplicación (*), división (/), división entera (//), resto (%), potencia (**). Ejemplo: 5 + 3 da 8, 10 / 3 da 3.333."}
{"instruction": "¿Por qué a veces la división da muchos decimales?", "response": "Cuando divides con /, siempre obtienes un resultado decimal (float), incluso si es exacto. Ejemplo: 4 / 2 da 2.0, no 2."}
{"instruction": "¿Cómo evito que aparezcan tantos decimales?", "response": "Puedes redondear con round() o convertir a entero con int(). Ejemplo: round(3.14159, 2) da 3.14, int(3.9) da 3 (elimina decimales)."}
{"instruction": "¿Qué son los strings y cómo los uso?", "response": "Los strings son cadenas de texto. Se escriben entre comillas simples o dobles. Puedes unirlos con + y repetirlos con *. Ejemplo: 'Hola' + ' ' + 'Mundo' da 'Hola Mundo', 'Ha' * 3 da 'HaHaHa'."}
{"instruction": "¿Cómo hago para que el programa espere a que yo presione algo?", "response": "Usa input() sin argumentos. Ejemplo: input('Presiona Enter para continuar...') detiene el programa hasta que presiones Enter."}
{"instruction": "¿Cómo guardo el resultado de una operación?", "response": "Asignándolo a una variable. Ejemplo: resultado = 5 + 3 guarda 8 en la variable 'resultado'. Luego puedes usar print(resultado) para verlo."}
{"instruction": "¿Puedo usar palabras como 'print' o 'if' como nombres de variable?", "response": "No debes usarlas. Esas son palabras reservadas del lenguaje. Si las usas, Python te dará error. Usa nombres como 'mi_print' o 'resultado_if'."}
{"instruction": "¿Cómo hago comentarios en mi código?", "response": "Usa # para comentarios de una línea. Todo lo que esté después de # en esa línea será ignorado. Ejemplo: # Esto es un comentario; x = 5  # Esto también es comentario."}
{"instruction": "¿Para qué sirven los comentarios?", "response": "Para explicar qué hace el código, para desactivar temporalmente código, o para dejar notas para ti o para otros programadores. No afectan la ejecución del programa."}
{"instruction": "¿Cómo repito algo muchas veces?", "response": "Con bucles. El bucle for repite un número determinado de veces. Ejemplo: for i in range(3): print('Hola') imprime 'Hola' tres veces."}
{"instruction": "¿Qué hace exactamente range(3)?", "response": "range(3) genera los números 0, 1, 2. Se usa en bucles para repetir algo 3 veces. Si quieres empezar en 1, usa range(1, 4) que genera 1, 2, 3."}
{"instruction": "¿Cómo hago que algo se repita hasta que ocurra algo?", "response": "Con while. Ejemplo: contador = 0; while contador < 3: print(contador); contador += 1. Esto imprime 0, 1, 2. El bucle se repite mientras contador sea menor que 3."}
{"instruction": "¿Cómo evito un bucle infinito?", "response": "Asegúrate de que la condición del while eventualmente sea falsa. Normalmente, cambias una variable dentro del bucle. Ejemplo: en while x < 10, debes aumentar x dentro del bucle."}
{"instruction": "¿Cómo tomo decisiones en mi programa?", "response": "Con if, elif y else. Ejemplo: if edad >= 18: print('Mayor'); else: print('Menor'). El programa sigue un camino u otro según la condición."}
{"instruction": "¿Puedo poner un if dentro de otro?", "response": "Sí, se llama anidar. Ejemplo: if x > 0: if y > 0: print('Ambos positivos'). Pero es mejor usar operadores lógicos: if x > 0 and y > 0."}
{"instruction": "¿Qué son los operadores lógicos?", "response": "Son and (y), or (o), not (no). Se usan para combinar condiciones. Ejemplo: if edad >= 18 and tiene_licencia: ambas deben ser verdaderas."}
{"instruction": "¿Cómo comparo si algo NO es verdad?", "response": "Usas not o !=. Ejemplo: if not es_verdadero:, o if x != 10: (x no es igual a 10)."}
{"instruction": "¿Cómo guardo varios valores juntos?", "response": "En una lista. Ejemplo: numeros = [1, 2, 3, 4, 5]. Puedes acceder a cada elemento por su posición, empezando en 0: numeros[0] es 1."}
{"instruction": "¿Qué puedo guardar en una lista?", "response": "Puedes guardar cualquier tipo de dato: números, texto, booleanos, incluso otras listas. Ejemplo: mixta = [1, 'hola', True]."}
{"instruction": "¿Cómo agrego algo a una lista que ya existe?", "response": "Con append(). Ejemplo: lista = [1, 2]; lista.append(3) la convierte en [1, 2, 3]."}
{"instruction": "¿Cómo sé cuántos elementos tiene una lista?", "response": "Con len(). Ejemplo: len([1,2,3]) da 3."}
{"instruction": "¿Cómo busco algo en una lista?", "response": "Puedes usar in para ver si existe, o un bucle para encontrarlo. Ejemplo: if 5 in lista: print('Encontrado'). O for x in lista: if x == 5: print('Encontrado en posición', lista.index(x))."}
{"instruction": "¿Qué hago si quiero modificar un elemento de la lista?", "response": "Accede por su índice y asígnalo. Ejemplo: lista = [10,20,30]; lista[1] = 99 cambia la lista a [10,99,30]."}
{"instruction": "¿Cómo elimino algo de una lista?", "response": "Con remove() para eliminar por valor, o pop() para eliminar por posición. Ejemplo: lista = [1,2,3]; lista.remove(2) deja [1,3]; lista.pop(0) elimina el primer elemento."}
{"instruction": "¿Qué es una función y por qué la usaría?", "response": "Una función es un bloque de código que realiza una tarea específica. La usas para no repetir código, para organizar y para hacer el programa más legible."}
{"instruction": "¿Cómo creo mi propia función?", "response": "Usas def, un nombre, paréntesis y dos puntos. Ejemplo: def saludar(): print('Hola'). Luego la llamas con saludar()."}
{"instruction": "¿Cómo hago que mi función reciba datos?", "response": "Usas parámetros dentro de los paréntesis. Ejemplo: def saludar(nombre): print('Hola', nombre). Llamas: saludar('Ana')."}
{"instruction": "¿Cómo hago que mi función devuelva un resultado?", "response": "Usas return. Ejemplo: def sumar(a,b): return a+b. Luego resultado = sumar(3,4) guarda 7."}
{"instruction": "¿Puedo tener una función sin return?", "response": "Sí, pero entonces no devuelve ningún valor. Solo ejecuta código como imprimir en pantalla."}
{"instruction": "¿Qué pasa si llamo a una función que no existe?", "response": "Obtienes un NameError. Asegúrate de haber definido la función antes de llamarla, y de escribir su nombre correctamente."}
{"instruction": "¿Cómo importo funciones que ya hizo otra persona?", "response": "Con import. Ejemplo: import math te da acceso a funciones matemáticas como math.sqrt(16) que da 4.0."}
{"instruction": "¿Qué módulos son útiles para empezar?", "response": "math (matemáticas), random (números aleatorios), datetime (fechas y horas). Pero al principio puedes hacer mucho sin módulos."}
{"instruction": "¿Cómo manejo errores para que mi programa no se detenga?", "response": "Usa try y except. Ejemplo: try: numero = int('abc'); except: print('Eso no es un número'). El programa continúa después del except."}
{"instruction": "¿Cómo guardo datos permanentemente?", "response": "En archivos. Ejemplo: with open('datos.txt','w') as f: f.write('Hola'). Esto crea un archivo datos.txt con 'Hola'."}
{"instruction": "¿Cómo leo datos de un archivo?", "response": "Ejemplo: with open('datos.txt','r') as f: contenido = f.read(). contenido tendrá todo el texto del archivo."}
{"instruction": "¿Por qué a veces se cierra solo el archivo?", "response": "Cuando usas with open(...) as, Python se encarga de cerrar el archivo automáticamente. Es la forma recomendada."}
{"instruction": "¿Cómo sé si un archivo existe antes de abrirlo?", "response": "Puedes usar os.path.exists() del módulo os. Ejemplo: import os; if os.path.exists('archivo.txt'): print('Existe')."}
{"instruction": "¿Qué es un diccionario y cómo es diferente de una lista?", "response": "Un diccionario guarda pares clave-valor, mientras una lista guarda elementos por posición. En diccionario accedes por clave, no por índice. Ejemplo: datos = {'nombre':'Ana','edad':20}; datos['nombre'] da 'Ana'."}
{"instruction": "¿Cuándo uso lista y cuándo diccionario?", "response": "Usa lista cuando el orden importa y quieres acceder por posición. Usa diccionario cuando quieres acceder por un nombre significativo (clave)."}
{"instruction": "¿Cómo sé si ya aprendí a programar?", "response": "Nunca se termina de aprender, pero sabes que estás progresando cuando puedes resolver problemas por ti mismo, entender mensajes de error y escribir programas que funcionan."}
{"instruction": "¿Cuánto tiempo necesito para aprender Python?", "response": "Depende de tu dedicación. Con práctica diaria, en 2-3 meses puedes entender los fundamentos. Para ser competente, se necesitan 6-12 meses de práctica constante."}
{"instruction": "¿Qué hago si me atoro en un problema?", "response": "1. Divide el problema en partes más pequeñas. 2. Prueba cada parte por separado. 3. Usa print() para ver valores intermedios. 4. Busca en internet el mensaje de error. 5. Pide ayuda en foros como Stack Overflow."}
{"instruction": "¿Es normal sentir que no entiendo nada al principio?", "response": "Totalmente normal. Todos los programadores pasaron por eso. La programación es una nueva forma de pensar. Con práctica constante, empezarás a entender los patrones."}
{"instruction": "¿Qué proyecto simple puedo hacer para practicar?", "response": "1. Calculadora básica. 2. Lista de tareas (agregar, mostrar, eliminar). 3. Juego de adivinar un número. 4. Conversor de unidades. 5. Programa que lea y procese un archivo de texto."}
{"instruction": "¿Qué es un algoritmo y por qué es importante?", "response": "Un algoritmo es un conjunto de pasos ordenados para resolver un problema. Es importante porque permite crear soluciones eficientes y replicables. Ejemplo: algoritmo para hacer té: 1) hervir agua, 2) poner té, 3) esperar, 4) servir. En código: agua = hervir(); taza = poner_te(agua); servir(taza)."}
{"instruction": "¿Cómo funciona el algoritmo de búsqueda lineal paso a paso?", "response": "La búsqueda lineal revisa cada elemento hasta encontrar el buscado. Ejemplo: buscar el número 5 en [2,7,5,1]. Pasos: 1) Verificar 2 ≠ 5, 2) Verificar 7 ≠ 5, 3) Verificar 5 = 5 → encontrado. Código: def busqueda_lineal(lista, objetivo): for elemento in lista: if elemento == objetivo: return True; return False."}
{"instruction": "¿Cuál es la diferencia entre algoritmo iterativo y recursivo?", "response": "Iterativo usa bucles, recursivo se llama a sí mismo. Ejemplo factorial: iterativo: resultado=1; for i in range(1,n+1): resultado*=i. Recursivo: def factorial(n): if n<=1: return 1; return n*factorial(n-1). Ambos resuelven lo mismo, pero la recursión puede ser más elegante para ciertos problemas."}
{"instruction": "¿Cómo ordeno números manualmente como lo haría una computadora?", "response": "Puedes usar el algoritmo de ordenamiento por selección: 1) Encontrar el mínimo, 2) Ponerlo al inicio, 3) Repetir con el resto. Ejemplo: [3,1,2] → mínimo=1 → [1,3,2] → mínimo del resto=2 → [1,2,3]. Código: def ordenar(lista): for i in range(len(lista)): min_idx = i; for j in range(i+1, len(lista)): if lista[j] < lista[min_idx]: min_idx = j; lista[i], lista[min_idx] = lista[min_idx], lista[i]."}
{"instruction": "¿Qué es un algoritmo de 'divide y vencerás'?", "response": "Divide el problema en subproblemas más pequeños, resuelve cada uno y combina soluciones. Ejemplo: ordenamiento por mezcla (merge sort): 1) Dividir lista en mitades, 2) Ordenar cada mitad, 3) Mezclar mitades ordenadas. Código: def merge_sort(lista): if len(lista) <= 1: return lista; medio = len(lista)//2; izquierda = merge_sort(lista[:medio]); derecha = merge_sort(lista[medio:]); return mezclar(izquierda, derecha)."}
{"instruction": "¿Cómo funciona el algoritmo de búsqueda binaria?", "response": "Búsqueda binaria requiere lista ordenada. Pasos: 1) Comparar elemento central con objetivo, 2) Si es igual → encontrado, 3) Si objetivo es menor → buscar en mitad izquierda, 4) Si es mayor → buscar en mitad derecha, 5) Repetir. Código: def busqueda_binaria(lista, objetivo): inicio=0; fin=len(lista)-1; while inicio<=fin: medio=(inicio+fin)//2; if lista[medio]==objetivo: return medio; elif lista[medio]<objetivo: inicio=medio+1; else: fin=medio-1; return -1."}
{"instruction": "¿Qué es la complejidad algorítmica y por qué importa?", "response": "La complejidad mide cuánto tiempo o memoria necesita un algoritmo según el tamaño de entrada. Importa para saber si será rápido con datos grandes. Ejemplo: búsqueda lineal tiene complejidad O(n) (tiempo crece linealmente), búsqueda binaria O(log n) (mucho más rápido). Si n=1000, búsqueda lineal revisa hasta 1000 elementos, binaria solo ~10."}
{"instruction": "¿Cómo encuentro el número mayor en una lista?", "response": "Algoritmo: 1) Asumir que el primero es el mayor, 2) Comparar con cada elemento, 3) Actualizar si encuentras uno mayor. Ejemplo: lista=[3,7,2,9,1]; mayor=3 → comparar 7>3 → mayor=7 → 2<7 → 9>7 → mayor=9 → 1<9 → resultado=9. Código: def encontrar_mayor(lista): mayor=lista[0]; for num in lista[1:]: if num>mayor: mayor=num; return mayor."}
{"instruction": "¿Cómo sumo todos los números de una lista eficientemente?", "response": "El algoritmo más eficiente es recorrer una vez sumando. Ejemplo: lista=[1,2,3,4]; suma=0 → +1=1 → +2=3 → +3=6 → +4=10. Código: def sumar_lista(lista): suma=0; for num in lista: suma+=num; return suma. Python tiene sum(lista) que hace lo mismo."}
{"instruction": "¿Qué es un algoritmo de ordenamiento burbuja?", "response": "Ordenamiento burbuja compara elementos adyacentes y los intercambia si están en orden incorrecto. Ejemplo: [5,3,8,1] → comparar 5>3 → intercambiar → [3,5,8,1] → 5<8 → ok → 8>1 → intercambiar → [3,5,1,8] → repetir hasta ordenado. Código: def burbuja(lista): n=len(lista); for i in range(n): for j in range(0,n-i-1): if lista[j]>lista[j+1]: lista[j],lista[j+1]=lista[j+1],lista[j]."}
{"instruction": "¿Cómo verificar si una palabra es palíndromo?", "response": "Un palíndromo se lee igual al derecho y al revés. Algoritmo: 1) Eliminar espacios y minúsculas, 2) Comparar con su reverso. Ejemplo: 'ana' → reverso 'ana' → igual → verdadero. Código: def es_palindromo(texto): texto=texto.lower().replace(' ',''); return texto==texto[::-1]."}
{"instruction": "¿Cómo genero la secuencia de Fibonacci?", "response": "Secuencia: cada número es suma de los dos anteriores: 0,1,1,2,3,5,8... Algoritmo: def fibonacci(n): if n<=1: return n; a,b=0,1; for _ in range(2,n+1): a,b=b,a+b; return b. Ejemplo: fibonacci(6)=8."}
{"instruction": "¿Cómo encontrar números primos eficientemente?", "response": "Algoritmo para verificar si n es primo: 1) Si n<=1 → no primo, 2) Revisar divisores desde 2 hasta √n, 3) Si algún divisor tiene resto 0 → no primo. Ejemplo: n=7 → divisores 2,3 (√7≈2.6) → ninguno divide → primo. Código: def es_primo(n): if n<=1: return False; for i in range(2,int(n**0.5)+1): if n%i==0: return False; return True."}
{"instruction": "¿Cómo contar cuántas veces aparece cada elemento en una lista?", "response": "Algoritmo usando diccionario: 1) Recorrer lista, 2) Para cada elemento, incrementar su contador. Ejemplo: lista=[1,2,1,3,2]; contar={1:0,2:0,3:0} → elemento1→contar[1]=1 → elemento2→contar[2]=1 → elemento1→contar[1]=2 → etc. Código: def contar_elementos(lista): conteo={}; for elemento in lista: conteo[elemento]=conteo.get(elemento,0)+1; return conteo."}
{"instruction": "¿Cómo invertir una lista sin usar funciones incorporadas?", "response": "Algoritmo: 1) Crear lista vacía, 2) Recorrer original del final al inicio, 3) Agregar cada elemento a la nueva. Ejemplo: [1,2,3] → tomar 3 → [3] → tomar 2 → [3,2] → tomar 1 → [3,2,1]. Código: def invertir_lista(lista): invertida=[]; for i in range(len(lista)-1,-1,-1): invertida.append(lista[i]); return invertida."}
{"instruction": "¿Cómo encontrar elementos comunes entre dos listas?", "response": "Algoritmo de intersección: 1) Para cada elemento de lista1, 2) Verificar si está en lista2, 3) Si está, agregar a resultado. Ejemplo: [1,2,3] y [2,3,4] → elementos comunes: [2,3]. Código: def interseccion(lista1,lista2): comunes=[]; for elemento in lista1: if elemento in lista2 and elemento not in comunes: comunes.append(elemento); return comunes."}
{"instruction": "¿Cómo ordenar una lista de strings alfabéticamente?", "response": "Algoritmo de ordenamiento por inserción: 1) Tomar cada string, 2) Insertarlo en posición correcta en lista ordenada parcial. Ejemplo: ['banana','apple','cherry'] → 'banana' → ['banana'] → 'apple'<'banana' → ['apple','banana'] → 'cherry'>'banana' → ['apple','banana','cherry']. Código: def ordenar_strings(lista): for i in range(1,len(lista)): actual=lista[i]; j=i-1; while j>=0 and actual<lista[j]: lista[j+1]=lista[j]; j-=1; lista[j+1]=actual."}
{"instruction": "¿Cómo eliminar duplicados de una lista manteniendo el orden?", "response": "Algoritmo: 1) Crear nueva lista vacía, 2) Recorrer original, 3) Agregar solo si no está ya en nueva. Ejemplo: [1,2,2,3,1] → 1 → [1] → 2 → [1,2] → 2 ya está → 3 → [1,2,3] → 1 ya está. Código: def eliminar_duplicados(lista): unicos=[]; for elemento in lista: if elemento not in unicos: unicos.append(elemento); return unicos."}
{"instruction": "¿Cómo encontrar el segundo número más grande en una lista?", "response": "Algoritmo: 1) Encontrar el mayor, 2) Encontrar el mayor excluyendo el primero. Ejemplo: [5,3,8,1] → mayor=8 → lista sin 8=[5,3,1] → segundo mayor=5. Código: def segundo_mayor(lista): mayor=max(lista); lista_sin_mayor=[x for x in lista if x!=mayor]; return max(lista_sin_mayor) if lista_sin_mayor else None."}
{"instruction": "¿Cómo calcular el promedio de una lista?", "response": "Algoritmo: 1) Sumar todos elementos, 2) Dividir por cantidad de elementos. Ejemplo: [10,20,30] → suma=60 → cantidad=3 → promedio=20. Código: def promedio(lista): if not lista: return 0; return sum(lista)/len(lista)."}
{"instruction": "¿Cómo verificar si dos strings son anagramas?", "response": "Anagramas tienen mismas letras en diferente orden. Algoritmo: 1) Convertir a minúsculas, 2) Ordenar letras, 3) Comparar resultados. Ejemplo: 'roma' y 'amor' → ordenar ambos → 'amor' y 'amor' → iguales → anagramas. Código: def son_anagramas(s1,s2): s1=s1.lower().replace(' ',''); s2=s2.lower().replace(' ',''); return sorted(s1)==sorted(s2)."}
{"instruction": "¿Cómo encontrar la sublista más larga creciente?", "response": "Problema: encontrar subsecuencia creciente más larga. Algoritmo básico: 1) Recorrer lista, 2) Llevar cuenta de secuencia actual, 3) Actualizar máximo cuando secuencia termine. Ejemplo: [1,3,2,4,5] → secuencias: 1-3 (largo=2), 2-4-5 (largo=3) → máximo=3. Código: def sublista_creciente(lista): if not lista: return 0; max_len=1; actual_len=1; for i in range(1,len(lista)): if lista[i]>lista[i-1]: actual_len+=1; max_len=max(max_len,actual_len); else: actual_len=1; return max_len."}
{"instruction": "¿Cómo rotar una lista k posiciones?", "response": "Rotar significa mover elementos al inicio/final. Algoritmo: 1) Calcular índice real de rotación (k % largo), 2) Dividir lista en dos partes, 3) Reunir en orden inverso. Ejemplo: [1,2,3,4,5] rotar 2 → [4,5,1,2,3]. Código: def rotar_lista(lista,k): n=len(lista); k=k%n; return lista[-k:]+lista[:-k] if k!=0 else lista."}
{"instruction": "¿Cómo encontrar el elemento que más se repite en una lista?", "response": "Algoritmo: 1) Contar frecuencia de cada elemento, 2) Encontrar elemento con mayor conteo. Ejemplo: [1,2,2,3,2,1] → conteo={1:2,2:3,3:1} → máximo=2 con 3 apariciones. Código: def mas_frecuente(lista): if not lista: return None; conteo={}; for elemento in lista: conteo[elemento]=conteo.get(elemento,0)+1; return max(conteo, key=conteo.get)."}
{"instruction": "¿Cómo sumar matrices (listas de listas)?", "response": "Algoritmo: 1) Verificar mismas dimensiones, 2) Sumar elemento a elemento. Ejemplo: [[1,2],[3,4]] + [[5,6],[7,8]] = [[6,8],[10,12]]. Código: def sumar_matrices(a,b): resultado=[]; for i in range(len(a)): fila=[]; for j in range(len(a[0])): fila.append(a[i][j]+b[i][j]); resultado.append(fila); return resultado."}
{"instruction": "¿Cómo multiplicar matrices?", "response": "Multiplicación de matrices: elemento (i,j) = suma de productos de fila i de A por columna j de B. Ejemplo: 2x2 matrices. Código: def multiplicar_matrices(a,b): filas_a=len(a); cols_a=len(a[0]); cols_b=len(b[0]); resultado=[[0]*cols_b for _ in range(filas_a)]; for i in range(filas_a): for j in range(cols_b): for k in range(cols_a): resultado[i][j]+=a[i][k]*b[k][j]; return resultado."}
{"instruction": "¿Cómo implementar una pila (stack)?", "response": "Pila: LIFO (último en entrar, primero en salir). Algoritmo: 1) Lista vacía, 2) push = agregar al final, 3) pop = quitar del final. Ejemplo: pila=[] → push(1) → [1] → push(2) → [1,2] → pop() → devuelve 2, pila=[1]. Código: class Pila: def __init__(self): self.items=[]; def push(self,item): self.items.append(item); def pop(self): return self.items.pop() if self.items else None; def esta_vacia(self): return len(self.items)==0."}
{"instruction": "¿Cómo implementar una cola (queue)?", "response": "Cola: FIFO (primero en entrar, primero en salir). Algoritmo: 1) Lista vacía, 2) enqueue = agregar al final, 3) dequeue = quitar del inicio. Ejemplo: cola=[] → enqueue(1) → [1] → enqueue(2) → [1,2] → dequeue() → devuelve 1, cola=[2]. Código: class Cola: def __init__(self): self.items=[]; def enqueue(self,item): self.items.append(item); def dequeue(self): return self.items.pop(0) if self.items else None; def esta_vacia(self): return len(self.items)==0."}
{"instruction": "¿Cómo calcular el factorial de un número?", "response": "Factorial: n! = n × (n-1) × ... × 1. Algoritmo iterativo: resultado=1; for i in range(1,n+1): resultado*=i. Algoritmo recursivo: def factorial(n): if n<=1: return 1; return n*factorial(n-1). Ejemplo: 5! = 120."}
{"instruction": "¿Cómo encontrar el máximo común divisor (MCD)?", "response": "Algoritmo de Euclides: MCD(a,b) = MCD(b, a%b) hasta que b=0. Ejemplo: MCD(48,18) → 48%18=12 → MCD(18,12) → 18%12=6 → MCD(12,6) → 12%6=0 → MCD=6. Código: def mcd(a,b): while b: a,b=b,a%b; return abs(a)."}
{"instruction": "¿Cómo encontrar el mínimo común múltiplo (MCM)?", "response": "MCM(a,b) = (a*b) / MCD(a,b). Ejemplo: a=12,b=18 → MCD=6 → MCM=(12*18)/6=36. Código: def mcm(a,b): return abs(a*b)//mcd(a,b) if a and b else 0."}
{"instruction": "¿Cómo convertir decimal a binario?", "response": "Algoritmo: 1) Dividir número entre 2, 2) Guardar residuo, 3) Repetir con cociente hasta 0, 4) Leer residuos en orden inverso. Ejemplo: 10 decimal → 10/2=5 residuo0 → 5/2=2 residuo1 → 2/2=1 residuo0 → 1/2=0 residuo1 → binario: 1010. Código: def decimal_a_binario(n): if n==0: return '0'; binario=''; while n>0: binario=str(n%2)+binario; n//=2; return binario."}
{"instruction": "¿Cómo convertir binario a decimal?", "response": "Algoritmo: 1) Tomar cada dígito de derecha a izquierda, 2) Multiplicar por 2^posición, 3) Sumar resultados. Ejemplo: 1010 binario → posiciones: 0,1,2,3 → (0×2^0)+(1×2^1)+(0×2^2)+(1×2^3)=0+2+0+8=10 decimal. Código: def binario_a_decimal(binario): decimal=0; for i,digito in enumerate(reversed(binario)): if digito=='1': decimal+=2**i; return decimal."}
{"instruction": "¿Cómo verificar si un número es perfecto?", "response": "Número perfecto: igual a suma de sus divisores propios. Algoritmo: 1) Encontrar divisores propios (excluyendo n), 2) Sumarlos, 3) Comparar con n. Ejemplo: 6 → divisores:1,2,3 → suma=6 → perfecto. Código: def es_perfecto(n): if n<=1: return False; suma=0; for i in range(1,n//2+1): if n%i==0: suma+=i; return suma==n."}
{"instruction": "¿Cómo generar todos los pares posibles de una lista?", "response": "Algoritmo: doble bucle para combinar elementos. Ejemplo: [1,2,3] → pares: (1,2),(1,3),(2,3). Código: def generar_pares(lista): pares=[]; for i in range(len(lista)): for j in range(i+1,len(lista)): pares.append((lista[i],lista[j])); return pares."}
{"instruction": "¿Cómo ordenar una lista usando quicksort?", "response": "Quicksort: 1) Elegir pivote, 2) Dividir en menores y mayores al pivote, 3) Ordenar recursivamente cada parte. Ejemplo: [3,6,8,10,1,2] pivote=6 → menores[3,1,2], mayores[8,10] → ordenar cada → [1,2,3]+[6]+[8,10]. Código: def quicksort(lista): if len(lista)<=1: return lista; pivote=lista[len(lista)//2]; menores=[x for x in lista if x<pivote]; iguales=[x for x in lista if x==pivote]; mayores=[x for x in lista if x>pivote]; return quicksort(menores)+iguales+quicksort(mayores)."}
{"instruction": "¿Cómo implementar búsqueda por interpolación?", "response": "Búsqueda por interpolación mejora a binaria en listas uniformemente distribuidas. Estimación: pos = inicio + ((objetivo - lista[inicio])*(fin-inicio)//(lista[fin]-lista[inicio])). Código: def busqueda_interpolacion(lista, objetivo): inicio,fin=0,len(lista)-1; while inicio<=fin and lista[inicio]<=objetivo<=lista[fin]: if inicio==fin: return inicio if lista[inicio]==objetivo else -1; pos=inicio+((objetivo-lista[inicio])*(fin-inicio))//(lista[fin]-lista[inicio]); if lista[pos]==objetivo: return pos; elif lista[pos]<objetivo: inicio=pos+1; else: fin=pos-1; return -1."}
{"instruction": "¿Cómo calcular potencias eficientemente?", "response": "Algoritmo de exponenciación binaria: dividir problema. Ejemplo: 3^5 = 3^4 × 3^1. Código: def potencia(base, exp): resultado=1; while exp>0: if exp%2==1: resultado*=base; base*=base; exp//=2; return resultado."}
{"instruction": "¿Cómo encontrar la moda de una lista?", "response": "Moda: valor(es) que más aparece. Algoritmo: 1) Contar frecuencia, 2) Encontrar máximo frecuencia, 3) Recoger todos con esa frecuencia. Ejemplo: [1,2,2,3,1,2] → frecuencias: {1:2,2:3,3:1} → moda=2. Código: def moda(lista): if not lista: return []; conteo={}; for x in lista: conteo[x]=conteo.get(x,0)+1; max_frec=max(conteo.values()); return [x for x,f in conteo.items() if f==max_frec]."}
{"instruction": "¿Cómo calcular la mediana de una lista?", "response": "Mediana: valor central en lista ordenada. Algoritmo: 1) Ordenar lista, 2) Si tamaño impar → elemento central, 3) Si par → promedio dos centrales. Ejemplo: [3,1,2] → ordenada[1,2,3] → mediana=2. [4,1,3,2] → ordenada[1,2,3,4] → mediana=(2+3)/2=2.5. Código: def mediana(lista): ordenada=sorted(lista); n=len(ordenada); medio=n//2; if n%2==1: return ordenada[medio]; else: return (ordenada[medio-1]+ordenada[medio])/2."}
{"instruction": "¿Cómo encontrar el camino más corto en una cuadrícula?", "response": "Problema: de esquina superior izquierda a inferior derecha moviéndose solo derecha/abajo. Algoritmo: número de caminos = combinaciones. Ejemplo: cuadrícula 2x2 → caminos=2. Código: def caminos_cuadricula(m,n): if m==1 or n==1: return 1; return caminos_cuadricula(m-1,n)+caminos_cuadricula(m,n-1). Para eficiencia: usar programación dinámica."}
{"instruction": "¿Cómo resolver el problema de la mochila 0/1?", "response": "Problema: maximizar valor sin exceder capacidad. Algoritmo de programación dinámica: tabla donde dp[i][w] = máximo valor con i primeros items y capacidad w. Código básico: def mochila(capacidad, pesos, valores): n=len(pesos); dp=[[0]*(capacidad+1) for _ in range(n+1)]; for i in range(1,n+1): for w in range(capacidad+1): if pesos[i-1]<=w: dp[i][w]=max(dp[i-1][w], valores[i-1]+dp[i-1][w-pesos[i-1]]); else: dp[i][w]=dp[i-1][w]; return dp[n][capacidad]."}
{"instruction": "¿Cómo verificar si un grafo es conexo?", "response": "Grafo conexo: existe camino entre cualquier par de vértices. Algoritmo BFS/DFS: 1) Partir de un vértice, 2) Visitar todos alcanzables, 3) Si todos visitados → conexo. Código para lista de adyacencia: def es_conexo(grafo): if not grafo: return True; visitados=set(); cola=[0]; while cola: v=cola.pop(0); if v not in visitados: visitados.add(v); cola.extend(grafo[v]); return len(visitados)==len(grafo)."}
{"instruction": "¿Cómo encontrar el ciclo más corto en un grafo?", "response": "Para grafos no ponderados, BFS desde cada vértice. Ejemplo: grafo con 3 vértices en triángulo → ciclo largo=3. Código básico: def ciclo_minimo(grafo): n=len(grafo); min_ciclo=float('inf'); for v in range(n): distancias=[-1]*n; padres=[-1]*n; distancias[v]=0; cola=[v]; while cola: actual=cola.pop(0); for vecino in grafo[actual]: if distancias[vecino]==-1: distancias[vecino]=distancias[actual]+1; padres[vecino]=actual; cola.append(vecino); elif padres[actual]!=vecino: min_ciclo=min(min_ciclo, distancias[actual]+distancias[vecino]+1); return min_ciclo if min_ciclo!=float('inf') else -1."}
{"instruction": "¿Cómo implementar el algoritmo de Dijkstra?", "response": "Dijkstra encuentra caminos más cortos desde un origen. Algoritmo: 1) Distancias iniciales infinito, 2) Origen distancia 0, 3) Mientras haya vértices no procesados, 4) Tomar vértice con menor distancia, 5) Actualizar distancias de vecinos. Código básico: import heapq; def dijkstra(grafo, origen): n=len(grafo); dist=[float('inf')]*n; dist[origen]=0; heap=[(0,origen)]; while heap: d_actual,v_actual=heapq.heappop(heap); if d_actual>dist[v_actual]: continue; for vecino,peso in grafo[v_actual]: nueva_dist=dist[v_actual]+peso; if nueva_dist<dist[vecino]: dist[vecino]=nueva_dist; heapq.heappush(heap,(nueva_dist,vecino)); return dist."}
{"instruction": "¿Cómo ordenar usando mergesort?", "response": "Mergesort: 1) Dividir lista en mitades hasta tamaño 1, 2) Fusionar mitades ordenadas. Ejemplo: [3,1,4,2] → dividir [3,1] y [4,2] → dividir [3],[1] y [4],[2] → fusionar [1,3] y [2,4] → fusionar [1,2,3,4]. Código: def mergesort(lista): if len(lista)<=1: return lista; medio=len(lista)//2; izq=mergesort(lista[:medio]); der=mergesort(lista[medio:]); return fusionar(izq,der); def fusionar(a,b): resultado=[]; i=j=0; while i<len(a) and j<len(b): if a[i]<=b[j]: resultado.append(a[i]); i+=1; else: resultado.append(b[j]); j+=1; resultado.extend(a[i:]); resultado.extend(b[j:]); return resultado."}
{"instruction": "¿Cómo encontrar la sublista con suma máxima?", "response": "Problema de subarray máximo. Algoritmo de Kadane: 1) maxima_actual = maxima_global = lista[0], 2) Para cada elemento: maxima_actual = max(elemento, maxima_actual+elemento), 3) maxima_global = max(maxima_global, maxima_actual). Ejemplo: [-2,1,-3,4,-1,2,1,-5,4] → suma máxima=6 (subarray [4,-1,2,1]). Código: def max_subarray_suma(lista): if not lista: return 0; max_actual=max_global=lista[0]; for num in lista[1:]: max_actual=max(num, max_actual+num); max_global=max(max_global, max_actual); return max_global."}
{"instruction": "¿Cómo implementar el algoritmo de Floyd-Warshall?", "response": "Floyd-Warshall encuentra caminos más cortos entre todos los pares. Algoritmo: 3 bucles anidados actualizando distancias. Ejemplo: grafo con 3 nodos. Código: def floyd_warshall(grafo): n=len(grafo); dist=[[float('inf')]*n for _ in range(n)]; for i in range(n): dist[i][i]=0; for j in grafo[i]: dist[i][j]=grafo[i][j]; for k in range(n): for i in range(n): for j in range(n): if dist[i][k]+dist[k][j]<dist[i][j]: dist[i][j]=dist[i][k]+dist[k][j]; return dist."}
{"instruction": "¿Cómo resolver las Torres de Hanoi?", "response": "Torres de Hanoi: mover n discos de torre A a C usando B como auxiliar. Algoritmo recursivo: 1) Mover n-1 discos de A a B, 2) Mover disco n de A a C, 3) Mover n-1 discos de B a C. Código: def hanoi(n, origen, destino, auxiliar): if n==1: print(f'Mover disco 1 de {origen} a {destino}'); return; hanoi(n-1, origen, auxiliar, destino); print(f'Mover disco {n} de {origen} a {destino}'); hanoi(n-1, auxiliar, destino, origen)."}
{"instruction": "¿Cómo generar permutaciones de una lista?", "response": "Permutaciones: todos los órdenes posibles. Algoritmo recursivo: 1) Si lista vacía → permutación vacía, 2) Para cada elemento, generar permutaciones del resto. Ejemplo: [1,2] → permutaciones: [1,2],[2,1]. Código: def permutaciones(lista): if len(lista)<=1: return [lista]; resultado=[]; for i in range(len(lista)): actual=lista[i]; resto=lista[:i]+lista[i+1:]; for p in permutaciones(resto): resultado.append([actual]+p); return resultado."}
{"instruction": "¿Cómo generar combinaciones de k elementos?", "response": "Combinaciones: seleccionar k elementos sin importar orden. Algoritmo recursivo: 1) Caso base k=0 → combinación vacía, 2) Tomar/ignorar primer elemento. Ejemplo: [1,2,3], k=2 → combinaciones: [1,2],[1,3],[2,3]. Código: def combinaciones(lista, k): if k==0: return [[]]; if not lista: return []; primera=lista[0]; resto=lista[1:]; con_primera=[[primera]+c for c in combinaciones(resto, k-1)]; sin_primera=combinaciones(resto, k); return con_primera+sin_primera."}
{"instruction": "¿Cómo implementar búsqueda en profundidad (DFS)?", "response": "DFS explora lo más profundo posible antes de retroceder. Algoritmo recursivo: 1) Marcar nodo como visitado, 2) Para cada vecino no visitado, llamar DFS. Ejemplo: grafo con nodos 0-1-2, empezando en 0 → visita 0, luego 1, luego 2. Código: def dfs(grafo, inicio, visitados=None): if visitados is None: visitados=set(); visitados.add(inicio); print(inicio); for vecino in grafo[inicio]: if vecino not in visitados: dfs(grafo, vecino, visitados); return visitados."}
{"instruction": "¿Cómo implementar búsqueda en amplitud (BFS)?", "response": "BFS explora por niveles. Algoritmo con cola: 1) Encolar inicio, 2) Mientras cola no vacía, 3) Desencolar, procesar, 4) Encolar vecinos no visitados. Ejemplo: grafo con nodos 0-1-2, empezando en 0 → visita 0, luego 1, luego 2. Código: from collections import deque; def bfs(grafo, inicio): visitados=set(); cola=deque([inicio]); visitados.add(inicio); while cola: v=cola.popleft(); print(v); for vecino in grafo[v]: if vecino not in visitados: visitados.add(vecino); cola.append(vecino); return visitados."}
{"instruction": "¿Cómo verificar si un grafo es bipartito?", "response": "Grafo bipartito: vértices divididos en dos conjuntos sin aristas dentro del mismo conjunto. Algoritmo BFS coloreando: 1) Asignar color a inicio, 2) Para cada vértice, colorear vecinos con color opuesto, 3) Si conflicto → no bipartito. Código: def es_bipartito(grafo): color={}; for nodo in range(len(grafo)): if nodo not in color: color[nodo]=0; cola=[nodo]; while cola: actual=cola.pop(0); for vecino in grafo[actual]: if vecino not in color: color[vecino]=1-color[actual]; cola.append(vecino); elif color[vecino]==color[actual]: return False; return True."}
{"instruction": "¿Cómo encontrar puentes en un grafo?", "response": "Puente: arista cuya remoción desconecta el grafo. Algoritmo con DFS: llevar tiempo de descubrimiento y low value. Código: def encontrar_puentes(grafo): n=len(grafo); tiempo=0; descubrimiento=[-1]*n; low=[-1]*n; padres=[-1]*n; puentes=[]; def dfs(u): nonlocal tiempo; descubrimiento[u]=low[u]=tiempo; tiempo+=1; for v in grafo[u]: if descubrimiento[v]==-1: padres[v]=u; dfs(v); low[u]=min(low[u], low[v]); if low[v]>descubrimiento[u]: puentes.append((u,v)); elif v!=padres[u]: low[u]=min(low[u], descubrimiento[v]); for i in range(n): if descubrimiento[i]==-1: dfs(i); return puentes."}
{"instruction": "¿Cómo resolver el problema de la subsecuencia común más larga?", "response": "LCS: subsecuencia común más larga entre dos strings. Algoritmo programación dinámica: tabla donde dp[i][j] = LCS de primeros i chars de A y j chars de B. Código: def lcs(A,B): m,n=len(A),len(B); dp=[[0]*(n+1) for _ in range(m+1)]; for i in range(1,m+1): for j in range(1,n+1): if A[i-1]==B[j-1]: dp[i][j]=dp[i-1][j-1]+1; else: dp[i][j]=max(dp[i-1][j], dp[i][j-1]); return dp[m][n]."}
{"instruction": "¿Cómo encontrar el par de puntos más cercano?", "response": "Problema: dados n puntos en plano, encontrar par con distancia mínima. Algoritmo divide y vencerás: 1) Ordenar por x, 2) Dividir en mitades, 3) Recursivamente encontrar mínimas en mitades, 4) Considerar puntos cerca de la división. Código básico: import math; def distancia(p1,p2): return math.hypot(p1[0]-p2[0], p1[1]-p2[1]); def mas_cercano(puntos): pts_ordenados=sorted(puntos); return mas_cercano_rec(pts_ordenados); def mas_cercano_rec(pts): n=len(pts); if n<=3: return min(distancia(pts[i],pts[j]) for i in range(n) for j in range(i+1,n)); medio=n//2; izq=pts[:medio]; der=pts[medio:]; d_izq=mas_cercano_rec(izq); d_der=mas_cercano_rec(der); d=min(d_izq, d_der); # Verificar puntos cerca de la línea divisoria ... return d."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por selección?", "response": "El algoritmo de ordenamiento por selección busca el elemento más pequeño en cada iteración y lo coloca en su posición correcta. Pasos: 1) Encontrar el mínimo en la lista, 2) Intercambiarlo con el primer elemento, 3) Repetir con el resto de la lista. Ejemplo: [64,25,12,22,11] → mínimo=11 → [11,25,12,22,64] → siguiente mínimo=12 → [11,12,25,22,64] → etc. Código: def seleccion(lista): n=len(lista); for i in range(n): min_idx=i; for j in range(i+1,n): if lista[j]<lista[min_idx]: min_idx=j; lista[i],lista[min_idx]=lista[min_idx],lista[i]; return lista."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por inserción?", "response": "El algoritmo de ordenamiento por inserción construye la lista ordenada un elemento a la vez, insertando cada elemento en su posición correcta. Pasos: 1) Tomar el primer elemento como ordenado, 2) Para cada siguiente elemento, comparar con los ordenados e insertar en posición correcta. Ejemplo: [12,11,13,5,6] → [12] → [11,12] → [11,12,13] → [5,11,12,13] → [5,6,11,12,13]. Código: def insercion(lista): for i in range(1,len(lista)): actual=lista[i]; j=i-1; while j>=0 and actual<lista[j]: lista[j+1]=lista[j]; j-=1; lista[j+1]=actual; return lista."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por conteo?", "response": "El ordenamiento por conteo cuenta la frecuencia de cada elemento y usa esa información para colocar elementos en su posición. Requiere conocer el rango de valores. Ejemplo: [1,4,1,2,7,5,2] con rango 0-9. Pasos: 1) Contar apariciones, 2) Calcular posiciones acumuladas, 3) Colocar elementos en posiciones correctas. Código: def conteo(lista, max_val): conteo=[0]*(max_val+1); for num in lista: conteo[num]+=1; resultado=[]; for i in range(max_val+1): resultado.extend([i]*conteo[i]); return resultado."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por montículos (heapsort)?", "response": "Heapsort usa una estructura de montículo (heap) para ordenar. Pasos: 1) Construir un max-heap, 2) Intercambiar raíz (mayor) con último elemento, 3) Reducir tamaño del heap y restaurar propiedad, 4) Repetir. Ejemplo: [4,10,3,5,1] → construir max-heap → [10,5,3,4,1] → intercambiar 10 y 1 → [1,5,3,4,10] → restaurar heap en [1,5,3,4]. Código: def heapify(lista,n,i): mayor=i; izq=2*i+1; der=2*i+2; if izq<n and lista[izq]>lista[mayor]: mayor=izq; if der<n and lista[der]>lista[mayor]: mayor=der; if mayor!=i: lista[i],lista[mayor]=lista[mayor],lista[i]; heapify(lista,n,mayor); def heapsort(lista): n=len(lista); for i in range(n//2-1,-1,-1): heapify(lista,n,i); for i in range(n-1,0,-1): lista[0],lista[i]=lista[i],lista[0]; heapify(lista,i,0); return lista."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por mezcla natural?", "response": "El ordenamiento por mezcla natural es una variante externa de merge sort que aprovega secuencias ya ordenadas en los datos. Pasos: 1) Identificar secuencias ordenadas, 2) Mezclar pares de secuencias, 3) Repetir hasta tener una sola secuencia. Código básico: def mezcla_natural(lista): if len(lista)<=1: return lista; secuencias=[]; i=0; while i<len(lista): j=i+1; while j<len(lista) and lista[j-1]<=lista[j]: j+=1; secuencias.append(lista[i:j]); i=j; while len(secuencias)>1: nuevas_secuencias=[]; for k in range(0,len(secuencias),2): if k+1<len(secuencias): nuevas_secuencias.append(mezclar(secuencias[k],secuencias[k+1])); else: nuevas_secuencias.append(secuencias[k]); secuencias=nuevas_secuencias; return secuencias[0]."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por cubetas?", "response": "El ordenamiento por cubetas divide los elementos en grupos (cubetas), ordena cada cubeta y luego las combina. Ejemplo: [0.42,0.32,0.23,0.52,0.25] con 10 cubetas (0-1). Pasos: 1) Crear cubetas, 2) Distribuir elementos según valor, 3) Ordenar cada cubeta, 4) Combinar. Código: def cubetas(lista): n=len(lista); cubetas=[[] for _ in range(n)]; for num in lista: idx=int(num*n); cubetas[idx].append(num); for i in range(n): cubetas[i].sort(); resultado=[]; for cubeta in cubetas: resultado.extend(cubeta); return resultado."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por radix?", "response": "El ordenamiento por radix ordena números procesando dígitos individuales, de menos a más significativo. Usa un ordenamiento estable como subrutina. Ejemplo: [170,45,75,90,802,24,2,66]. Pasos: 1) Ordenar por dígito de unidades, 2) Ordenar por dígito de decenas, 3) Ordenar por dígito de centenas. Código: def counting_sort_radix(lista, exp): n=len(lista); output=[0]*n; count=[0]*10; for i in range(n): index=(lista[i]//exp)%10; count[index]+=1; for i in range(1,10): count[i]+=count[i-1]; i=n-1; while i>=0: index=(lista[i]//exp)%10; output[count[index]-1]=lista[i]; count[index]-=1; i-=1; for i in range(n): lista[i]=output[i]; def radix_sort(lista): max_val=max(lista); exp=1; while max_val//exp>0: counting_sort_radix(lista,exp); exp*=10; return lista."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por casilleros?", "response": "El ordenamiento por casilleros es similar al de cubetas pero para números enteros en un rango pequeño. Se crea un arreglo de conteo. Ejemplo: [4,2,2,8,3,3,1] con rango 0-9. Pasos: 1) Contar frecuencia de cada valor, 2) Reconstruir lista ordenada. Código: def casilleros(lista, max_val): conteo=[0]*(max_val+1); for num in lista: conteo[num]+=1; resultado=[]; for i in range(max_val+1): resultado.extend([i]*conteo[i]); return resultado."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por burbuja optimizado?", "response": "La versión optimizada de burbuja detiene el proceso si no hay intercambios en una pasada, indicando que la lista ya está ordenada. Código: def burbuja_optimizada(lista): n=len(lista); for i in range(n): intercambiado=False; for j in range(0,n-i-1): if lista[j]>lista[j+1]: lista[j],lista[j+1]=lista[j+1],lista[j]; intercambiado=True; if not intercambiado: break; return lista."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por cocktail shaker?", "response": "El cocktail shaker ordena en ambas direcciones (izquierda a derecha y derecha a izquierda) para mejorar el rendimiento de burbuja. Ejemplo: [5,1,4,2,8,0,2]. Pasos: 1) Burbuja hacia la derecha llevando el mayor al final, 2) Burbuja hacia la izquierda llevando el menor al inicio, 3) Repetir hasta ordenar. Código: def cocktail_shaker(lista): n=len(lista); inicio=0; fin=n-1; while inicio<fin: # Derecha a izquierda for i in range(inicio,fin): if lista[i]>lista[i+1]: lista[i],lista[i+1]=lista[i+1],lista[i]; fin-=1; # Izquierda a derecha for i in range(fin-1,inicio-1,-1): if lista[i]>lista[i+1]: lista[i],lista[i+1]=lista[i+1],lista[i]; inicio+=1; return lista."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por Gnome?", "response": "El ordenamiento Gnome es similar a inserción pero más simple. Funciona comparando elementos adyacentes y moviéndose hacia atrás cuando encuentra un desorden. Ejemplo: [34,2,10,-9]. Pasos: 1) Si el elemento actual es mayor o igual al anterior, avanzar, 2) Si no, intercambiar y retroceder. Código: def gnome_sort(lista): i=0; n=len(lista); while i<n: if i==0 or lista[i]>=lista[i-1]: i+=1; else: lista[i],lista[i-1]=lista[i-1],lista[i]; i-=1; return lista."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por peine?", "response": "El ordenamiento por peine mejora a burbuja usando un gap mayor que 1 inicialmente, reduciéndolo gradualmente. Ejemplo: [8,4,1,3,7,6,2,5] con gap inicial=8/1.3≈6. Pasos: 1) Comparar elementos separados por gap, 2) Reducir gap, 3) Continuar hasta gap=1 y aplicar burbuja. Código: def comb_sort(lista): n=len(lista); gap=n; shrink=1.3; ordenado=False; while not ordenado: gap=int(gap/shrink); if gap<=1: gap=1; ordenado=True; for i in range(n-gap): if lista[i]>lista[i+gap]: lista[i],lista[i+gap]=lista[i+gap],lista[i]; ordenado=False; return lista."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por Shell?", "response": "El ordenamiento de Shell es una generalización de inserción que compara elementos separados por un gap, reduciendo el gap gradualmente. Ejemplo: [12,34,54,2,3] con gaps: 5/2=2, luego 1. Pasos: 1) Ordenar por inserción con gap=2, 2) Ordenar por inserción con gap=1. Código: def shell_sort(lista): n=len(lista); gap=n//2; while gap>0: for i in range(gap,n): temp=lista[i]; j=i; while j>=gap and lista[j-gap]>temp: lista[j]=lista[j-gap]; j-=gap; lista[j]=temp; gap//=2; return lista."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por bitonic?", "response": "El ordenamiento bitonic funciona construyendo secuencias bitónicas (primero creciente luego decreciente o viceversa) y luego mezclándolas. Requiere que el tamaño de la lista sea potencia de 2. Código: def comp_intercambio(lista,i,j,direccion): if (direccion==1 and lista[i]>lista[j]) or (direccion==0 and lista[i]<lista[j]): lista[i],lista[j]=lista[j],lista[i]; def bitonic_mezclar(lista,low,cnt,direccion): if cnt>1: k=cnt//2; for i in range(low,low+k): comp_intercambio(lista,i,i+k,direccion); bitonic_mezclar(lista,low,k,direccion); bitonic_mezclar(lista,low+k,k,direccion); def bitonic_sort(lista,low,cnt,direccion): if cnt>1: k=cnt//2; bitonic_sort(lista,low,k,1); bitonic_sort(lista,low+k,k,0); bitonic_mezclar(lista,low,cnt,direccion); return lista; def ordenar_bitonic(lista): n=len(lista); # Asegurar que n es potencia de 2; si no, rellenar; bitonic_sort(lista,0,n,1); return lista."}
{"instruction": "¿Cómo implementar el algoritmo de ordenamiento por árbol binario?", "response": "El ordenamiento por árbol binario inserta todos los elementos en un árbol de búsqueda binaria y luego realiza un recorrido en orden. Código: class Nodo: def __init__(self,valor): self.valor=valor; self.izq=None; self.der=None; def insertar(raiz,valor): if raiz is None: return Nodo(valor); if valor<raiz.valor: raiz.izq=insertar(raiz.izq,valor); else: raiz.der=insertar(raiz.der,valor); return raiz; def inorden(raiz,resultado): if raiz: inorden(raiz.izq,resultado); resultado.append(raiz.valor); inorden(raiz.der,resultado); def tree_sort(lista): raiz=None; for valor in lista: raiz=insertar(raiz,valor); resultado=[]; inorden(raiz,resultado); return resultado."}
{"instruction": "¿Cómo funciona el algoritmo de ordenamiento por distribución?", "response": "El ordenamiento por distribución es similar al de conteo pero para elementos con claves múltiples. Se usa en radix sort. Código: def distribucion(lista, exp): n=len(lista); output=[0]*n; count=[0]*10; for i in range(n): index=(lista[i]//exp)%10; count[index]+=1; for i in range(1,10): count[i]+=count[i-1]; i=n-1; while i>=0: index=(lista[i]//exp)%10; output[count[index]-1]=lista[i]; count[index]-=1; i-=1; for i in range(n): lista[i]=output[i];"}

{"instruction": "¿Cómo implementar el algoritmo de búsqueda ternaria?", "response": "La búsqueda ternaria divide el espacio de búsqueda en tres partes para encontrar máximos o mínimos en funciones unimodales. Ejemplo: buscar máximo de f(x) en [l,r]. Pasos: 1) Calcular m1 y m2 que dividen el intervalo en tres, 2) Si f(m1)<f(m2), buscar en [m1,r], sino en [l,m2]. Código: def busqueda_ternaria(f,l,r,eps=1e-9): while r-l>eps: m1=l+(r-l)/3; m2=r-(r-l)/3; if f(m1)<f(m2): l=m1; else: r=m2; return (l+r)/2."}
{"instruction": "¿Cómo funciona el algoritmo de búsqueda por saltos?", "response": "La búsqueda por saltos (jump search) busca en una lista ordenada saltando bloques de tamaño √n y luego haciendo búsqueda lineal en el bloque. Ejemplo: lista de 10 elementos, tamaño de salto=3. Pasos: 1) Saltar cada √n elementos hasta encontrar un valor mayor o igual al objetivo, 2) Hacer búsqueda lineal en el bloque anterior. Código: import math; def jump_search(lista, objetivo): n=len(lista); paso=int(math.sqrt(n)); previo=0; while lista[min(paso,n)-1]<objetivo: previo=paso; paso+=int(math.sqrt(n)); if previo>=n: return -1; for i in range(previo, min(paso,n)): if lista[i]==objetivo: return i; return -1."}
{"instruction": "¿Cómo implementar el algoritmo de búsqueda por interpolación?", "response": "La búsqueda por interpolación estima la posición del objetivo en una lista ordenada uniformemente distribuida. Fórmula: pos = inicio + ((objetivo - lista[inicio])*(fin-inicio)//(lista[fin]-lista[inicio])). Código: def interpolacion_search(lista, objetivo): inicio=0; fin=len(lista)-1; while inicio<=fin and lista[inicio]<=objetivo<=lista[fin]: if inicio==fin: return inicio if lista[inicio]==objetivo else -1; pos=inicio+((objetivo-lista[inicio])*(fin-inicio))//(lista[fin]-lista[inicio]); if lista[pos]==objetivo: return pos; elif lista[pos]<objetivo: inicio=pos+1; else: fin=pos-1; return -1."}
{"instruction": "¿Cómo funciona el algoritmo de búsqueda exponencial?", "response": "La búsqueda exponencial encuentra un rango donde podría estar el objetivo y luego aplica búsqueda binaria. Útil para listas ilimitadas o muy grandes. Pasos: 1) Empezar con sublista de tamaño 1, 2) Duplicar el tamaño hasta que el último elemento sea mayor o igual al objetivo, 3) Hacer búsqueda binaria en ese rango. Código: def busqueda_exponencial(lista, objetivo): if lista[0]==objetivo: return 0; n=len(lista); i=1; while i<n and lista[i]<=objetivo: i*=2; return busqueda_binaria(lista, objetivo, i//2, min(i,n-1));"}

{"instruction": "¿Cómo implementar el algoritmo de búsqueda de Fibonacci?", "response": "La búsqueda de Fibonacci divide la lista usando números de Fibonacci. Similar a búsqueda binaria pero con divisiones basadas en Fibonacci. Código: def fib_search(lista, objetivo): n=len(lista); fibMMm2=0; fibMMm1=1; fibM=fibMMm2+fibMMm1; while fibM<n: fibMMm2,fibMMm1=fibMMm1,fibM; fibM=fibMMm2+fibMMm1; offset=-1; while fibM>1: i=min(offset+fibMMm2, n-1); if lista[i]<objetivo: fibM=fibMMm1; fibMMm1=fibMMm2; fibMMm2=fibM-fibMMm1; offset=i; elif lista[i]>objetivo: fibM=fibMMm2; fibMMm1=fibMMm1-fibMMm2; fibMMm2=fibM-fibMMm1; else: return i; if fibMMm1 and lista[offset+1]==objetivo: return offset+1; return -1."}

{"instruction": "¿Cómo funciona el algoritmo de búsqueda por transformada de Fourier rápida?", "response": "La FFT acelera la multiplicación de polinomios y la convolución, útil en procesamiento de señales. Implementación recursiva: def fft(a, invert=False): n=len(a); if n==1: return; a0=a[::2]; a1=a[1::2]; fft(a0,invert); fft(a1,invert); ang=2*math.pi/n*(-1 if invert else 1); w=complex(1); wn=complex(math.cos(ang),math.sin(ang)); for i in range(n//2): a[i]=a0[i]+w*a1[i]; a[i+n//2]=a0[i]-w*a1[i]; w*=wn; if invert: for i in range(n): a[i]/=2; return a."}

{"instruction": "¿Cómo implementar el algoritmo de Euclides extendido?", "response": "El algoritmo de Euclides extendido encuentra el MCD y los coeficientes x,y tales que ax+by=MCD(a,b). Código: def euclides_extendido(a,b): if b==0: return a,1,0; mcd,x1,y1=euclides_extendido(b,a%b); x=y1; y=x1-(a//b)*y1; return mcd,x,y."}
{"instruction": "¿Cómo funciona el algoritmo de la criba de Eratóstenes?", "response": "La criba de Eratóstenes encuentra todos los números primos hasta un límite n. Pasos: 1) Crear lista de True de tamaño n+1, 2) Marcar 0 y 1 como no primos, 3) Para cada número i desde 2 hasta √n, si es primo, marcar sus múltiplos como no primos. Código: def criba_eratostenes(n): if n<2: return []; primo=[True]*(n+1); primo[0]=primo[1]=False; for i in range(2,int(n**0.5)+1): if primo[i]: for j in range(i*i,n+1,i): primo[j]=False; return [i for i in range(n+1) if primo[i]]."}
{"instruction": "¿Cómo implementar el algoritmo de la criba de Atkin?", "response": "La criba de Atkin es más rápida que Eratóstenes para grandes n. Se basa en formas cuadráticas. Código: def criba_atkin(limite): if limite<2: return []; primo=[False]*(limite+1); for x in range(1,int(limite**0.5)+1): for y in range(1,int(limite**0.5)+1): n=4*x*x+y*y; if n<=limite and n%60 in [1,13,17,29,37,41,49,53]: primo[n]=not primo[n]; n=3*x*x+y*y; if n<=limite and n%60 in [7,19,31,43]: primo[n]=not primo[n]; n=3*x*x-y*y; if x>y and n<=limite and n%60 in [11,23,47,59]: primo[n]=not primo[n]; for i in range(5,int(limite**0.5)+1): if primo[i]: for j in range(i*i,limite+1,i*i): primo[j]=False; return [2,3]+[i for i in range(5,limite+1) if primo[i]]."}
{"instruction": "¿Cómo funciona el algoritmo de Dijkstra para caminos más cortos?", "response": "Dijkstra encuentra los caminos más cortos desde un origen a todos los vértices en un grafo con pesos no negativos. Usa una cola de prioridad. Código: import heapq; def dijkstra(grafo, inicio): n=len(grafo); dist=[float('inf')]*n; dist[inicio]=0; heap=[(0,inicio)]; while heap: d_actual,v_actual=heapq.heappop(heap); if d_actual>dist[v_actual]: continue; for vecino,peso in grafo[v_actual]: nueva_dist=dist[v_actual]+peso; if nueva_dist<dist[vecino]: dist[vecino]=nueva_dist; heapq.heappush(heap,(nueva_dist,vecino)); return dist."}
{"instruction": "¿Cómo implementar el algoritmo de Bellman-Ford?", "response": "Bellman-Ford encuentra caminos más cortos desde un origen incluso con pesos negativos, detectando ciclos negativos. Relaja todas las aristas |V|-1 veces. Código: def bellman_ford(grafo, inicio): n=len(grafo); dist=[float('inf')]*n; dist[inicio]=0; for _ in range(n-1): for u in range(n): for v,peso in grafo[u]: if dist[u]!=float('inf') and dist[u]+peso<dist[v]: dist[v]=dist[u]+peso; for u in range(n): for v,peso in grafo[u]: if dist[u]!=float('inf') and dist[u]+peso<dist[v]: raise ValueError('Ciclo negativo detectado'); return dist."}
{"instruction": "¿Cómo funciona el algoritmo de Floyd-Warshall?", "response": "Floyd-Warshall encuentra los caminos más cortos entre todos los pares de vértices. Usa programación dinámica. Código: def floyd_warshall(grafo): n=len(grafo); dist=[[float('inf')]*n for _ in range(n)]; for i in range(n): dist[i][i]=0; for j,peso in grafo[i]: dist[i][j]=peso; for k in range(n): for i in range(n): for j in range(n): if dist[i][k]+dist[k][j]<dist[i][j]: dist[i][j]=dist[i][k]+dist[k][j]; return dist."}
{"instruction": "¿Cómo implementar el algoritmo de Kruskal para árbol de expansión mínima?", "response": "Kruskal encuentra el árbol de expansión mínima ordenando las aristas por peso y agregándolas si no forman ciclo. Usa estructura union-find. Código: class UnionFind: def __init__(self,n): self.padre=list(range(n)); self.rango=[0]*n; def find(self,x): if self.padre[x]!=x: self.padre[x]=self.find(self.padre[x]); return self.padre[x]; def union(self,x,y): raiz_x=self.find(x); raiz_y=self.find(y); if raiz_x==raiz_y: return False; if self.rango[raiz_x]<self.rango[raiz_y]: self.padre[raiz_x]=raiz_y; elif self.rango[raiz_x]>self.rango[raiz_y]: self.padre[raiz_y]=raiz_x; else: self.padre[raiz_y]=raiz_x; self.rango[raiz_x]+=1; return True; def kruskal(grafo): aristas=[]; n=len(grafo); for u in range(n): for v,peso in grafo[u]: aristas.append((peso,u,v)); aristas.sort(); uf=UnionFind(n); mst=[]; for peso,u,v in aristas: if uf.union(u,v): mst.append((u,v,peso)); if len(mst)==n-1: break; return mst."}
{"instruction": "¿Cómo funciona el algoritmo de Prim para árbol de expansión mínima?", "response": "Prim construye el árbol de expansión mínima comenzando desde un vértice, agregando en cada paso la arista de menor peso que conecta el árbol con un vértice fuera. Usa cola de prioridad. Código: import heapq; def prim(grafo, inicio=0): n=len(grafo); visitado=[False]*n; mst=[]; heap=[(0,inicio,-1)]; # (peso, vertice, padre) while heap: peso,v,padre=heapq.heappop(heap); if visitado[v]: continue; visitado[v]=True; if padre!=-1: mst.append((padre,v,peso)); for vecino,w in grafo[v]: if not visitado[vecino]: heapq.heappush(heap,(w,vecino,v)); return mst."}
{"instruction": "¿Cómo implementar el algoritmo de Boruvka para árbol de expansión mínima?", "response": "Boruvka es un algoritmo paralelizable para árbol de expansión mínima. En cada iteración, cada componente conectado elige la arista más barata que lo conecta a otro componente. Código: def boruvka(grafo): n=len(grafo); componentes=list(range(n)); aristas_por_componente=[None]*n; mst=[]; num_componentes=n; while num_componentes>1: for i in range(n): aristas_por_componente[i]=None; for u in range(n): for v,peso in grafo[u]: comp_u=componentes[u]; comp_v=componentes[v]; if comp_u!=comp_v: if aristas_por_componente[comp_u] is None or peso<aristas_por_componente[comp_u][2]: aristas_por_componente[comp_u]=(u,v,peso); if aristas_por_componente[comp_v] is None or peso<aristas_por_componente[comp_v][2]: aristas_por_componente[comp_v]=(u,v,peso); for arista in aristas_por_componente: if arista is not None: u,v,peso=arista; if componentes[u]!=componentes[v]: mst.append(arista); # Unir componentes antiguo=componentes[u]; nuevo=componentes[v]; for i in range(n): if componentes[i]==antiguo: componentes[i]=nuevo; num_componentes-=1; return mst."}
{"instruction": "¿Cómo funciona el algoritmo de Tarjan para componentes fuertemente conexas?", "response": "El algoritmo de Tarjan encuentra componentes fuertemente conexas en un grafo dirigido usando DFS y pilas. Código: def tarjan(grafo): n=len(grafo); index=0; indices=[-1]*n; low=[0]*n; en_pila=[False]*n; pila=[]; componentes=[]; def fuerte_conexo(v): nonlocal index; indices[v]=low[v]=index; index+=1; pila.append(v); en_pila[v]=True; for w in grafo[v]: if indices[w]==-1: fuerte_conexo(w); low[v]=min(low[v],low[w]); elif en_pila[w]: low[v]=min(low[v],indices[w]); if low[v]==indices[v]: componente=[]; while True: w=pila.pop(); en_pila[w]=False; componente.append(w); if w==v: break; componentes.append(componente); for v in range(n): if indices[v]==-1: fuerte_conexo(v); return componentes."}
{"instruction": "¿Cómo implementar el algoritmo de Kosaraju para componentes fuertemente conexas?", "response": "Kosaraju hace dos DFS: uno en el grafo original y otro en el transpuesto. Código: def kosaraju(grafo): n=len(grafo); visitado=[False]*n; orden=[]; def dfs1(v): visitado[v]=True; for w in grafo[v]: if not visitado[w]: dfs1(w); orden.append(v); for i in range(n): if not visitado[i]: dfs1(i); grafo_t=[[] for _ in range(n)]; for u in range(n): for v in grafo[u]: grafo_t[v].append(u); visitado=[False]*n; componentes=[]; def dfs2(v,componente): visitado[v]=True; componente.append(v); for w in grafo_t[v]: if not visitado[w]: dfs2(w,componente); while orden: v=orden.pop(); if not visitado[v]: componente=[]; dfs2(v,componente); componentes.append(componente); return componentes."}
{"instruction": "¿Cómo funciona el algoritmo de Fleury para encontrar trayectos eulerianos?", "response": "El algoritmo de Fleury encuentra un trayecto euleriano en un grafo euleriano. Regla: no cruzar un puente a menos que no haya alternativa. Código: def fleury(grafo): # Asume grafo euleriano; grafo es lista de adyacencia con aristas como pares (vecino, id_arista) n=len(grafo); # Primero, verificar grados; luego: visitado_aristas=set(); camino=[]; def dfs(v): for vecino,id_arista in grafo[v]: if id_arista not in visitado_aristas: # Verificar si la arista es puente (requiere detección de puentes) # Para simplificar, asumimos que no hay puentes o usamos un enfoque alternativo visitado_aristas.add(id_arista); dfs(vecino); camino.append(v); inicio=0; for i in range(n): if len(grafo[i])%2==1: inicio=i; break; dfs(inicio); camino.reverse(); return camino."}
{"instruction": "¿Cómo implementar el algoritmo de Hierholzer para circuito euleriano?", "response": "Hierholzer encuentra circuitos eulerianos en grafos eulerianos. Pasos: 1) Elegir un vértice inicial, 2) Seguir un camino hasta regresar al inicio, 3) Si hay vértices con aristas sin usar, integrar circuitos. Código: def hierholzer(grafo): n=len(grafo); # grafo es lista de adyacencia con aristas (vecino, id) grados=[len(grafo[i]) for i in range(n)]; for g in grados: if g%2!=0: return None; # No es euleriano circuito=[]; pila=[0]; while pila: v=pila[-1]; if grafo[v]: u,id_arista=grafo[v].pop(); grafo[u]=[(vec,id) for vec,id in grafo[u] if id!=id_arista]; # Eliminar arista del otro lado pila.append(u); else: circuito.append(pila.pop()); circuito.reverse(); return circuito."}
{"instruction": "¿Cómo funciona el algoritmo de Hopcroft-Karp para emparejamiento máximo?", "response": "Hopcroft-Karp encuentra el emparejamiento máximo en un grafo bipartito en O(√V E). Usa BFS para construir niveles y DFS para encontrar caminos aumentantes. Código: from collections import deque; INF=10**9; class HopcroftKarp: def __init__(self,n_left,n_right): self.n_left=n_left; self.n_right=n_right; self.adj=[[] for _ in range(n_left)]; def add_edge(self,u,v): self.adj[u].append(v); def bfs(self,dist,mate_left,mate_right): q=deque(); for u in range(self.n_left): if mate_left[u]==-1: dist[u]=0; q.append(u); else: dist[u]=INF; dist_null=INF; while q: u=q.popleft(); if dist[u]<dist_null: for v in self.adj[u]: if mate_right[v]==-1: dist_null=dist[u]+1; elif dist[mate_right[v]]==INF: dist[mate_right[v]]=dist[u]+1; q.append(mate_right[v]); return dist_null!=INF; def dfs(self,u,dist,mate_left,mate_right): for v in self.adj[u]: if mate_right[v]==-1 or (dist[mate_right[v]]==dist[u]+1 and self.dfs(mate_right[v],dist,mate_left,mate_right)): mate_left[u]=v; mate_right[v]=u; return True; return False; def max_matching(self): mate_left=[-1]*self.n_left; mate_right=[-1]*self.n_right; dist=[0]*self.n_left; matching=0; while self.bfs(dist,mate_left,mate_right): for u in range(self.n_left): if mate_left[u]==-1: if self.dfs(u,dist,mate_left,mate_right): matching+=1; return matching,mate_left,mate_right."}
{"instruction": "¿Cómo implementar el algoritmo de Edmonds-Karp para flujo máximo?", "response": "Edmonds-Karp es Ford-Fulkerson con BFS para encontrar caminos aumentantes. Código: from collections import deque; def edmonds_karp(grafo, fuente, sumidero): n=len(grafo); capacidad=[[0]*n for _ in range(n)]; for u in range(n): for v,cap in grafo[u]: capacidad[u][v]=cap; flujo=0; while True: camino=[-1]*n; camino[fuente]=fuente; cola=deque([fuente]); while cola and camino[sumidero]==-1: u=cola.popleft(); for v in range(n): if capacidad[u][v]>0 and camino[v]==-1: camino[v]=u; cola.append(v); if camino[sumidero]==-1: break; aumento=float('inf'); v=sumidero; while v!=fuente: u=camino[v]; aumento=min(aumento,capacidad[u][v]); v=u; v=sumidero; while v!=fuente: u=camino[v]; capacidad[u][v]-=aumento; capacidad[v][u]+=aumento; v=u; flujo+=aumento; return flujo."}
{"instruction": "¿Cómo funciona el algoritmo de Dinic para flujo máximo?", "response": "Dinic es más eficiente que Edmonds-Karp. Usa BFS para construir grafos en niveles y DFS para enviar flujo. Código: from collections import deque; class Dinic: def __init__(self,n): self.n=n; self.adj=[[] for _ in range(n)]; self.capacidad={}; def add_edge(self,u,v,cap): self.adj[u].append(v); self.adj[v].append(u); self.capacidad[(u,v)]=cap; self.capacidad[(v,u)]=0; def bfs(self,fuente,sumidero): self.nivel=[-1]*self.n; q=deque([fuente]); self.nivel[fuente]=0; while q: u=q.popleft(); for v in self.adj[u]: if self.nivel[v]==-1 and self.capacidad[(u,v)]>0: self.nivel[v]=self.nivel[u]+1; q.append(v); return self.nivel[sumidero]!=-1; def dfs(self,u,flujo,sumidero): if u==sumidero: return flujo; for i in range(self.ptr[u],len(self.adj[u])): v=self.adj[u][i]; if self.nivel[v]==self.nivel[u]+1 and self.capacidad[(u,v)]>0: flo=min(flujo,self.capacidad[(u,v)]); flujo_actual=self.dfs(v,flo,sumidero); if flujo_actual>0: self.capacidad[(u,v)]-=flujo_actual; self.capacidad[(v,u)]+=flujo_actual; return flujo_actual; self.ptr[u]+=1; return 0; def max_flow(self,fuente,sumidero): flujo_total=0; while self.bfs(fuente,sumidero): self.ptr=[0]*self.n; while True: flujo=self.dfs(fuente,float('inf'),sumidero); if flujo==0: break; flujo_total+=flujo; return flujo_total."}
{"instruction": "¿Cómo implementar el algoritmo de Kuhn-Munkres (asignación)?", "response": "El algoritmo de Kuhn-Munkres (Hungarian) resuelve el problema de asignación en matrices de costos. Código: def hungarian(costos): n=len(costos); u=[0]*(n+1); v=[0]*(n+1); p=[0]*(n+1); camino=[0]*(n+1); for i in range(1,n+1): p[0]=i; j0=0; minv=[float('inf')]*(n+1); visitado=[False]*(n+1); while True: visitado[j0]=True; i0=p[j0]; delta=float('inf'); j1=0; for j in range(1,n+1): if not visitado[j]: cur=costos[i0-1][j-1]-u[i0]-v[j]; if cur<minv[j]: minv[j]=cur; camino[j]=j0; if minv[j]<delta: delta=minv[j]; j1=j; for j in range(n+1): if visitado[j]: u[p[j]]+=delta; v[j]-=delta; else: minv[j]-=delta; j0=j1; if p[j0]==0: break; while True: j1=camino[j0]; p[j0]=p[j1]; j0=j1; if j0==0: break; asignacion=[-1]*n; for j in range(1,n+1): if p[j]!=0: asignacion[p[j]-1]=j-1; return -v[0], asignacion."}
{"instruction": "¿Cómo funciona el algoritmo de Johnson para caminos más cortos?", "response": "Johnson encuentra caminos más cortos entre todos los pares en grafos con pesos negativos (sin ciclos negativos). Usa Bellman-Ford para re-pesar las aristas y luego Dijkstra desde cada vértice. Código: import heapq; def johnson(grafo): n=len(grafo); # Agregar un vértice nuevo que conecte a todos con peso 0 nuevo_vertice=n; grafo_aux=[[] for _ in range(n+1)]; for u in range(n): for v,w in grafo[u]: grafo_aux[u].append((v,w)); grafo_aux[nuevo_vertice].append((u,0)); # Bellman-Ford desde el nuevo vértice h=[float('inf')]*(n+1); h[nuevo_vertice]=0; for _ in range(n): for u in range(n+1): for v,w in grafo_aux[u]: if h[u]!=float('inf') and h[u]+w<h[v]: h[v]=h[u]+w; # Verificar ciclos negativos for u in range(n+1): for v,w in grafo_aux[u]: if h[u]!=float('inf') and h[u]+w<h[v]: raise ValueError('Ciclo negativo detectado'); # Re-pesar las aristas grafo_repesado=[[] for _ in range(n)]; for u in range(n): for v,w in grafo[u]: nuevo_peso=w+h[u]-h[v]; grafo_repesado[u].append((v,nuevo_peso)); # Dijkstra desde cada vértice distancias=[[float('inf')]*n for _ in range(n)]; for s in range(n): dist=[float('inf')]*n; dist[s]=0; heap=[(0,s)]; while heap: d,u=heapq.heappop(heap); if d>dist[u]: continue; for v,w in grafo_repesado[u]: nd=d+w; if nd<dist[v]: dist[v]=nd; heapq.heappush(heap,(nd,v)); for v in range(n): if dist[v]!=float('inf'): distancias[s][v]=dist[v]-h[s]+h[v]; return distancias."}
{"instruction": "¿Cómo implementar el algoritmo de Boyer-Moore para búsqueda de patrón?", "response": "Boyer-Moore busca un patrón en un texto usando dos heurísticas: mal carácter y buen sufijo. Código: def boyer_moore(texto, patron): n=len(texto); m=len(patron); if m==0: return 0; # Tabla de mal carácter mal_caracter={}; for i in range(m): mal_caracter[patron[i]]=i; # Tabla de buen sufijo sufijo=[0]*(m+1); frontera=[0]*(m+1); frontera[m]=m+1; sufijo[m]=m+1; i=m; j=m+1; while i>0: while j<=m and patron[i-1]!=patron[j-1]: if sufijo[j]==0: sufijo[j]=j-i; j=frontera[j]; i-=1; j-=1; frontera[i]=j; for i in range(m+1): if sufijo[i]==0: sufijo[i]=frontera[0]; i=0; while i<=n-m: j=m-1; while j>=0 and patron[j]==texto[i+j]: j-=1; if j<0: yield i; i+=sufijo[0]; else: i+=max(sufijo[j+1], j-mal_caracter.get(texto[i+j], -1));"}

{"instruction": "¿Cómo funciona el algoritmo de Knuth-Morris-Pratt para búsqueda de patrón?", "response": "KMP preprocesa el patrón para crear una tabla de prefijos-sufijos, evitando retroceder en el texto. Código: def kmp(texto, patron): n=len(texto); m=len(patron); if m==0: return 0; # Construir tabla de prefijos lps=[0]*m; j=0; i=1; while i<m: if patron[i]==patron[j]: j+=1; lps[i]=j; i+=1; else: if j!=0: j=lps[j-1]; else: lps[i]=0; i+=1; # Buscar i=j=0; while i<n: if patron[j]==texto[i]: i+=1; j+=1; if j==m: yield i-j; j=lps[j-1]; else: if j!=0: j=lps[j-1]; else: i+=1;"}
{"instruction": "¿Cómo implementar el algoritmo de Rabin-Karp para búsqueda de patrón?", "response": "Rabin-Karp usa hashing para buscar patrones. Calcula hash del patrón y de ventanas del texto. Código: def rabin_karp(texto, patron, q=101): n=len(texto); m=len(patron); d=256; # tamaño del alfabeto h=pow(d,m-1)%q; p=t=0; for i in range(m): p=(d*p+ord(patron[i]))%q; t=(d*t+ord(texto[i]))%q; for i in range(n-m+1): if p==t: if texto[i:i+m]==patron: yield i; if i<n-m: t=(d*(t-ord(texto[i])*h)+ord(texto[i+m]))%q; if t<0: t+=q;"}
{"instruction": "¿Cómo funciona el algoritmo de Z para búsqueda de patrón?", "response": "El algoritmo Z construye un arreglo Z donde Z[i] es el largo del substring más largo que empieza en i y es también prefijo. Se usa para buscar patrones. Código: def z_algorithm(s): n=len(s); z=[0]*n; l=r=0; for i in range(1,n): if i<=r: z[i]=min(r-i+1,z[i-l]); while i+z[i]<n and s[z[i]]==s[i+z[i]]: z[i]+=1; if i+z[i]-1>r: l=i; r=i+z[i]-1; return z; def buscar_z(texto, patron): concat=patron+'$'+texto; z=z_algorithm(concat); m=len(patron); for i in range(m+1,len(z)): if z[i]==m: yield i-m-1;"}
{"instruction": "¿Cómo implementar el algoritmo de Aho-Corasick para múltiples patrones?", "response": "Aho-Corasick construye un autómata finito para buscar múltiples patrones simultáneamente. Código: class AhoCorasick: def __init__(self): self.trie=[{'salida':[],'fallo':0,'hijos':{}}]; self.estado=0; def agregar_patron(self,patron): estado=0; for c in patron: if c not in self.trie[estado]['hijos']: self.trie.append({'salida':[],'fallo':0,'hijos':{}}); self.trie[estado]['hijos'][c]=len(self.trie)-1; estado=self.trie[estado]['hijos'][c]; self.trie[estado]['salida'].append(patron); def construir_automata(self): from collections import deque; q=deque(); for c,estado in self.trie[0]['hijos'].items(): self.trie[estado]['fallo']=0; q.append(estado); while q: r=q.popleft(); for c,estado in self.trie[r]['hijos'].items(): q.append(estado); f=self.trie[r]['fallo']; while c not in self.trie[f]['hijos'] and f!=0: f=self.trie[f]['fallo']; self.trie[estado]['fallo']=self.trie[f]['hijos'].get(c,0); self.trie[estado]['salida'].extend(self.trie[self.trie[estado]['fallo']]['salida']); def buscar(self,texto): estado=0; resultados=[]; for i,c in enumerate(texto): while c not in self.trie[estado]['hijos'] and estado!=0: estado=self.trie[estado]['fallo']; estado=self.trie[estado]['hijos'].get(c,0); for patron in self.trie[estado]['salida']: resultados.append((i-len(patron)+1,patron)); return resultados;"}
{"instruction": "¿Cómo funciona el algoritmo de Manacher para palíndromos?", "response": "Manacher encuentra el palíndromo más largo en un string en tiempo lineal. Código: def manacher(s): T='#'+'#'.join(s)+'#'; n=len(T); P=[0]*n; C=R=0; for i in range(1,n-1): mirro=2*C-i; if i<R: P[i]=min(R-i,P[mirro]); while i-1-P[i]>=0 and i+1+P[i]<n and T[i-1-P[i]]==T[i+1+P[i]]: P[i]+=1; if i+P[i]>R: C=i; R=i+P[i]; max_len=max(P); centro=P.index(max_len); inicio=(centro-max_len)//2; return s[inicio:inicio+max_len];"}
{"instruction": "¿Cómo implementar el algoritmo de Wagner-Fischer para distancia de Levenshtein?", "response": "Wagner-Fischer calcula la distancia de edición (Levenshtein) entre dos strings usando programación dinámica. Código: def levenshtein(s1,s2): m,n=len(s1),len(s2); dp=[[0]*(n+1) for _ in range(m+1)]; for i in range(m+1): dp[i][0]=i; for j in range(n+1): dp[0][j]=j; for i in range(1,m+1): for j in range(1,n+1): costo=0 if s1[i-1]==s2[j-1] else 1; dp[i][j]=min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+costo); return dp[m][n];"}
{"instruction": "¿Cómo funciona el algoritmo de Needleman-Wunsch para alineamiento global?", "response": "Needleman-Wunsch alinea dos secuencias globalmente usando programación dinámica. Código: def needleman_wunsch(seq1,seq2,gap=-1,match=1,mismatch=-1): m,n=len(seq1),len(seq2); dp=[[0]*(n+1) for _ in range(m+1)]; for i in range(m+1): dp[i][0]=i*gap; for j in range(n+1): dp[0][j]=j*gap; for i in range(1,m+1): for j in range(1,n+1): if seq1[i-1]==seq2[j-1]: puntaje=dp[i-1][j-1]+match; else: puntaje=dp[i-1][j-1]+mismatch; dp[i][j]=max(puntaje, dp[i-1][j]+gap, dp[i][j-1]+gap); # Reconstruir alineamiento alineado1=''; alineado2=''; i=m; j=n; while i>0 or j>0: if i>0 and j>0 and ( (seq1[i-1]==seq2[j-1] and dp[i][j]==dp[i-1][j-1]+match) or (seq1[i-1]!=seq2[j-1] and dp[i][j]==dp[i-1][j-1]+mismatch) ): alineado1=seq1[i-1]+alineado1; alineado2=seq2[j-1]+alineado2; i-=1; j-=1; elif i>0 and dp[i][j]==dp[i-1][j]+gap: alineado1=seq1[i-1]+alineado1; alineado2='-'+alineado2; i-=1; else: alineado1='-'+alineado1; alineado2=seq2[j-1]+alineado2; j-=1; return dp[m][n],alineado1,alineado2;"}
{"instruction": "¿Cómo implementar el algoritmo de Smith-Waterman para alineamiento local?", "response": "Smith-Waterman encuentra el alineamiento local óptimo entre dos secuencias. Código: def smith_waterman(seq1,seq2,gap=-1,match=2,mismatch=-1): m,n=len(seq1),len(seq2); dp=[[0]*(n+1) for _ in range(m+1)]; max_val=0; max_pos=(0,0); for i in range(1,m+1): for j in range(1,n+1): if seq1[i-1]==seq2[j-1]: puntaje=dp[i-1][j-1]+match; else: puntaje=dp[i-1][j-1]+mismatch; dp[i][j]=max(0, puntaje, dp[i-1][j]+gap, dp[i][j-1]+gap); if dp[i][j]>max_val: max_val=dp[i][j]; max_pos=(i,j); # Reconstruir desde la posición máxima i,j=max_pos; alineado1=''; alineado2=''; while i>0 and j>0 and dp[i][j]!=0: if i>0 and j>0 and ( (seq1[i-1]==seq2[j-1] and dp[i][j]==dp[i-1][j-1]+match) or (seq1[i-1]!=seq2[j-1] and dp[i][j]==dp[i-1][j-1]+mismatch) ): alineado1=seq1[i-1]+alineado1; alineado2=seq2[j-1]+alineado2; i-=1; j-=1; elif i>0 and dp[i][j]==dp[i-1][j]+gap: alineado1=seq1[i-1]+alineado1; alineado2='-'+alineado2; i-=1; else: alineado1='-'+alineado1; alineado2=seq2[j-1]+alineado2; j-=1; return max_val,alineado1,alineado2;"}
{"instruction": "¿Cómo funciona el algoritmo de Viterbi para decodificación?", "response": "Viterbi decodifica la secuencia más probable de estados en un modelo oculto de Markov. Código: def viterbi(obs, estados, inicio_prob, trans_prob, emis_prob): V=[{}]; for st in estados: V[0][st]={'prob': inicio_prob[st]*emis_prob[st][obs[0]], 'prev':None}; for t in range(1,len(obs)): V.append({}); for st in estados: max_tr_prob=V[t-1][estados[0]]['prob']*trans_prob[estados[0]][st]; prev_st_selected=estados[0]; for prev_st in estados[1:]: tr_prob=V[t-1][prev_st]['prob']*trans_prob[prev_st][st]; if tr_prob>max_tr_prob: max_tr_prob=tr_prob; prev_st_selected=prev_st; max_prob=max_tr_prob*emis_prob[st][obs[t]]; V[t][st]={'prob':max_prob,'prev':prev_st_selected}; # Encontrar el máximo al final max_prob=max(value['prob'] for value in V[-1].values()); previous=None; for st,data in V[-1].items(): if data['prob']==max_prob: previous=st; break; # Recorrer hacia atrás camino=[previous]; for t in range(len(V)-1,0,-1): previous=V[t][previous]['prev']; camino.insert(0,previous); return camino,max_prob;"}
{"instruction": "¿Cómo implementar el algoritmo de Baum-Welch para entrenar HMM?", "response": "Baum-Welch es un algoritmo EM para estimar parámetros de un HMM. Código: def baum_welch(obs, estados, inicio_prob, trans_prob, emis_prob, n_iter=100): N=len(estados); T=len(obs); for it in range(n_iter): # Paso E: calcular alfa y beta alfa=[[0]*N for _ in range(T)]; for i in range(N): alfa[0][i]=inicio_prob[i]*emis_prob[i][obs[0]]; for t in range(1,T): for i in range(N): suma=0; for j in range(N): suma+=alfa[t-1][j]*trans_prob[j][i]; alfa[t][i]=suma*emis_prob[i][obs[t]]; beta=[[0]*N for _ in range(T)]; for i in range(N): beta[T-1][i]=1; for t in range(T-2,-1,-1): for i in range(N): suma=0; for j in range(N): suma+=trans_prob[i][j]*emis_prob[j][obs[t+1]]*beta[t+1][j]; beta[t][i]=suma; # Calcular gamma y xi gamma=[[0]*N for _ in range(T)]; xi=[[[0]*N for _ in range(N)] for _ in range(T-1)]; for t in range(T-1): denom=0; for i in range(N): for j in range(N): denom+=alfa[t][i]*trans_prob[i][j]*emis_prob[j][obs[t+1]]*beta[t+1][j]; for i in range(N): gamma[t][i]=0; for j in range(N): xi[t][i][j]=alfa[t][i]*trans_prob[i][j]*emis_prob[j][obs[t+1]]*beta[t+1][j]/denom; gamma[t][i]+=xi[t][i][j]; t=T-1; denom=sum(alfa[t][i] for i in range(N)); for i in range(N): gamma[t][i]=alfa[t][i]/denom; # Paso M: actualizar parámetros for i in range(N): inicio_prob[i]=gamma[0][i]; for i in range(N): denom=sum(gamma[t][i] for t in range(T-1)); for j in range(N): numer=sum(xi[t][i][j] for t in range(T-1)); trans_prob[i][j]=numer/denom if denom!=0 else 0; for i in range(N): denom=sum(gamma[t][i] for t in range(T)); for k in range(len(emis_prob[0])): numer=sum(gamma[t][i] for t in range(T) if obs[t]==k); emis_prob[i][k]=numer/denom if denom!=0 else 0; return inicio_prob,trans_prob,emis_prob;"}
{"instruction": "¿Cómo funciona el algoritmo de Forward-Backward para HMM?", "response": "El algoritmo Forward-Backward calcula probabilidades de estado suavizadas en un HMM. Código: def forward_backward(obs, estados, inicio_prob, trans_prob, emis_prob): N=len(estados); T=len(obs); # Forward alfa=[[0]*N for _ in range(T)]; for i in range(N): alfa[0][i]=inicio_prob[i]*emis_prob[i][obs[0]]; for t in range(1,T): for i in range(N): suma=0; for j in range(N): suma+=alfa[t-1][j]*trans_prob[j][i]; alfa[t][i]=suma*emis_prob[i][obs[t]]; # Backward beta=[[0]*N for _ in range(T)]; for i in range(N): beta[T-1][i]=1; for t in range(T-2,-1,-1): for i in range(N): suma=0; for j in range(N): suma+=trans_prob[i][j]*emis_prob[j][obs[t+1]]*beta[t+1][j]; beta[t][i]=suma; # Suavizado gamma=[[0]*N for _ in range(T)]; for t in range(T): norm=0; for i in range(N): gamma[t][i]=alfa[t][i]*beta[t][i]; norm+=gamma[t][i]; if norm!=0: for i in range(N): gamma[t][i]/=norm; return gamma;"}
{"instruction": "¿Cómo implementar el algoritmo de Metropolis-Hastings para MCMC?", "response": "Metropolis-Hastings es un algoritmo MCMC para muestrear de una distribución objetivo usando una propuesta. Código: import random; import math; def metropolis_hastings(target_density, proposal, initial, n_iter=10000): current=initial; samples=[current]; for i in range(n_iter): proposed=proposal(current); acceptance_prob=min(1, target_density(proposed)/target_density(current)); if random.random()<acceptance_prob: current=proposed; samples.append(current); return samples;"}
{"instruction": "¿Cómo funciona el algoritmo de Gibbs sampling?", "response": "Gibbs sampling es un MCMC que muestrea cada variable condicionada a las demás. Código: import random; def gibbs_sampling(cond_dists, initial, n_iter=10000): current=initial; samples=[current]; for i in range(n_iter): for j in range(len(current)): current[j]=cond_dists[j](current[:j]+current[j+1:]); samples.append(current[:]); return samples;"}